<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>JVM内存区域详解&nbsp;|&nbsp;Nick的博客</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="JVM内存区域详解">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="-fe1f32.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📚&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>分类</span>
        </div>
      </a>
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>关于我</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">JVM内存区域详解</h1>
    
      <div class="DateTagBar">
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--pink">
            <a href="tag/Java基础.html">Java基础</a>
          </span>
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--default">
            <a href="tag/JVM.html">JVM</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/e7e8fddeddbd4c70b3f3ad38d8171e6a" class="PageRoot"><div id="https://www.notion.so/fa295c6f9edd4c4a8002d4946c262110" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Java Virtual Machine - Java程序的运行环境（Java二进制字节码的运行环境）</span></span></p></div><div id="https://www.notion.so/f26916ac21f84a8d9c539c60f8e719bf" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">屏蔽java代码与底层操作系统之间的差异。</span></span></p></div><div id="https://www.notion.so/52ae39200bf64c5388b95b81f2d03881" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ffa8ffbb4-6913-43f3-88f3-c34d61de7d30%2FUntitled.png?width=1272&amp;table=block&amp;id=52ae3920-0bf6-4c53-88b9-5b81f2d03881"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ffa8ffbb4-6913-43f3-88f3-c34d61de7d30%2FUntitled.png?width=1272&amp;table=block&amp;id=52ae3920-0bf6-4c53-88b9-5b81f2d03881" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/0cd097c756c4463ea0ff47756961b500" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">好处：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/24143f865f014ea0a70907342558bac8" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">一次编写，到处运行</span></span></li><li id="https://www.notion.so/e6858a4011d249eab20cc20f1f39fa9b" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">自动内存管理，垃圾回收功能</span></span></li><li id="https://www.notion.so/04777b2d3a0b41e5acbbd1718f3e1af2" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">数组下标越界检查</span></span></li><li id="https://www.notion.so/5279557403cd402bbf186152344f8357" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">多态</span></span></li></ol><h1 id="https://www.notion.so/2b2e81a2c1974ce68c60b99c376f5494" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/2b2e81a2c1974ce68c60b99c376f5494"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">运行时数据区域</span></span></h1><div id="https://www.notion.so/febdf2c6210a404aaab21ee82d37705e" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb355a300-e396-4eca-9e32-d4116bf5a68c%2FUntitled.png?width=1546&amp;table=block&amp;id=febdf2c6-210a-404a-aab2-1ee82d37705e"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb355a300-e396-4eca-9e32-d4116bf5a68c%2FUntitled.png?width=1546&amp;table=block&amp;id=febdf2c6-210a-404a-aab2-1ee82d37705e" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h2 id="https://www.notion.so/a5eb4588dbd546a98a3296ee7b21f333" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/a5eb4588dbd546a98a3296ee7b21f333"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">程序计数器Program Counter Register</span></span></h2><div id="https://www.notion.so/ccf05d38c3cf4321b4305eedf7924c80" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0d9f8fa7-6763-4059-ab58-2ad5447ccde0%2FUntitled.png?width=1384&amp;table=block&amp;id=ccf05d38-c3cf-4321-b430-5eedf7924c80"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0d9f8fa7-6763-4059-ab58-2ad5447ccde0%2FUntitled.png?width=1384&amp;table=block&amp;id=ccf05d38-c3cf-4321-b430-5eedf7924c80" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/3ccf233c05a64facbc22de36fbefd0e7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器，存储了下一行字节码的地址。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。</span></span></p></div><div id="https://www.notion.so/4bd3442195444b63b863ed802b2400a8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</span></span></p></div><div id="https://www.notion.so/12e6708c4db4404c987d907a340405f5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所以程序计数器主要有两个</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">作用</strong></span><span class="SemanticString">：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/453390de44e44afb99661803dfd10064" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</span></span></li><li id="https://www.notion.so/3e613dc8e9c14976a12cb69b7edadd6a" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</span></span></li></ol><div id="https://www.notion.so/0a57f22efb8f4f37bdf6113d7cc0bff6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">注意 ：程序计数器是唯一一个不会出现 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">OutOfMemoryError</code></span><span class="SemanticString"> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</span></span></p></div><h2 id="https://www.notion.so/1f8f8588c8b44acf841739aca5f03293" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/1f8f8588c8b44acf841739aca5f03293"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">虚拟机栈Virtual Machine Stacks</span></span></h2><div id="https://www.notion.so/193f4f653301461c9f9eec726855b93e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">每个线程运行时需要的内存，称为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">虚拟机栈</strong></span></span></p></div><div id="https://www.notion.so/0a9baea59bbf445e85f26169e57b660b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">每个栈由多个</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">栈帧</strong></span><span class="SemanticString">组成，对应着每次方法调用时所占用的内存</span></span></p></div><div id="https://www.notion.so/f379c981a530428ca8a6636b97b8fdae" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">每个线程只有一个</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">活动栈帧</strong></span><span class="SemanticString">，对应着当前正在执行的方法</span></span></p></div><div id="https://www.notion.so/5b2d18f0912c48429b2fac4ff77fb134" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa1b8677f-cc0d-4671-8fb9-b08c800d3815%2FUntitled.png?width=712&amp;table=block&amp;id=5b2d18f0-912c-4842-9b2f-ac4ff77fb134"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa1b8677f-cc0d-4671-8fb9-b08c800d3815%2FUntitled.png?width=712&amp;table=block&amp;id=5b2d18f0-912c-4842-9b2f-ac4ff77fb134" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><details id="https://www.notion.so/c917981f51574a6996ebf022b534dd4b" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">栈内存分配越大越好吗？</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/924fd78528534b4ca3161f2957ade109" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">不是，栈内存分配越大，则线程数会减少，CPU效率降低。</span></span></p></div></div></details><details id="https://www.notion.so/3eb378dc3f684f549c6447fdd99a9d0b" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">方法内的局部变量是否线程安全？</span></span></summary><div class="Toggle__Content"><ul class="BulletedListWrapper"><li id="https://www.notion.so/fcf02aa4c9ef418b86284bb77c9161ff" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</span></span></li><li id="https://www.notion.so/21882430fcfc4249b2e28f46c642fdae" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</span></span></li></ul></div></details><h3 id="https://www.notion.so/e2a4671f03ff4143839725c8bc8869eb" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e2a4671f03ff4143839725c8bc8869eb"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">两种可能报错</span></span></h3><div id="https://www.notion.so/57e8e898df0a47409aa0d859eed524ce" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StackOverFlowError</code></span><span class="SemanticString"> 错误。</span></span></p></div><div id="https://www.notion.so/c09bedc70aa14022b3b36acb5edff514" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></span></span></p></div><div id="https://www.notion.so/e8d549f202df42b9bdbd4b4bca0ed4b7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">除了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StackOverFlowError</code></span><span class="SemanticString"> 错误之外，栈还可能会出现</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">OutOfMemoryError</code></span><span class="SemanticString">错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">OutOfMemoryError</code></span><span class="SemanticString">异常。</span></span></p></div><div id="https://www.notion.so/f0c61f74b6714fddb410709319ab67dc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">简单总结一下程序运行中栈可能会出现两种错误：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/3f0e8bddaecc44519752d1b78a63b665" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">StackOverFlowError</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">：</strong></span><span class="SemanticString"> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StackOverFlowError</code></span><span class="SemanticString"> 错误。</span></span></li><li id="https://www.notion.so/3a94679d837d40b3b6320a643d86191f" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">OutOfMemoryError</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">：</strong></span><span class="SemanticString"> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">OutOfMemoryError</code></span><span class="SemanticString">异常。</span></span></li></ul><h2 id="https://www.notion.so/c36ec18769ae48bcbac09bf38985c2c3" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/c36ec18769ae48bcbac09bf38985c2c3"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">本地方法栈Native Method Stacks</span></span></h2><div id="https://www.notion.so/6f34a54cd2ad498e9dfedf41a2dfc329" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">和虚拟机栈所发挥的作用非常相似，区别是： </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong></span><span class="SemanticString">比如hashCode，notify，wait都是本地方法。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</span></span></p></div><div id="https://www.notion.so/9ca6be24831a4b9887c414ae718e0d2c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</span></span></p></div><div id="https://www.notion.so/46497ab7ea9044be999bf684df4ead5f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StackOverFlowError</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">OutOfMemoryError</code></span><span class="SemanticString"> 两种错误。</span></span></p></div><h2 id="https://www.notion.so/89961bf5b11b4780bed41a244ff0614c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/89961bf5b11b4780bed41a244ff0614c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">堆Heap</span></span></h2><div id="https://www.notion.so/849325963d1c4a72a6ad5d5828783877" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">堆是JVM所管理的内存中最大的一块，是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的是存放对象实例。几乎所有的对象实例及数组都在堆里分配内存。</span></span></p></div><div id="https://www.notion.so/8265b584fadc495b80b6ef91bd752ed4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</span></span></p></div><div id="https://www.notion.so/054324dd9dad484d8a4e988d234b353a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Java 堆是垃圾收集器管理的主要区域，因此也被称作 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">GC 堆（Garbage Collected Heap）</strong></span><span class="SemanticString">。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</span></span></p></div><div id="https://www.notion.so/a2909f5bd42f4928938879aa9ee5167f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/2f17c522601647258d8a819cd5c96e2b" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">新生代内存(Young Generation)</span></span></li><li id="https://www.notion.so/71bd1ed247f94aaeb1d6260e28615c5b" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">老生代(Old Generation)</span></span></li><li id="https://www.notion.so/b44673c41b3e4ad891d7064da6312175" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">永久代(Permanent Generation)</span></span></li></ol><div id="https://www.notion.so/4989e68f27944a66b420bded44f18592" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</span></span></p></div><div id="https://www.notion.so/3deb337186a740578d7eca45d4ba5f2b" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6af2a6d9-3fd0-4b90-bed2-7d9634436fae%2FUntitled.png?width=871&amp;table=block&amp;id=3deb3371-86a7-4057-8d7e-ca45d4ba5f2b"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6af2a6d9-3fd0-4b90-bed2-7d9634436fae%2FUntitled.png?width=871&amp;table=block&amp;id=3deb3371-86a7-4057-8d7e-ca45d4ba5f2b" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/3d78e534dffa4559a027c933d2004a0b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong></span><span class="SemanticString"> （我会在方法区这部分内容详细介绍到）。</span></span></p></div><div id="https://www.notion.so/7c1adb8bbe4d4277ab0cff5e718555fa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">-XX:MaxTenuringThreshold</code></span><span class="SemanticString"> 来设置。</span></span></p></div><div id="https://www.notion.so/412ecf539bd1486da9fb6cbfeb172c88" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">堆这里最容易出现的就是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">OutOfMemoryError</code></span><span class="SemanticString"> 错误，并且出现这种错误之后的表现形式还会有几种，比如：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/c6851cd50b8e4c2a96963c6b179091ee" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</strong></code></span><span class="SemanticString"> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</span></span></li><li id="https://www.notion.so/e872bbcfd71b4571824e6a466e516464" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">java.lang.OutOfMemoryError: Java heap space</strong></code></span><span class="SemanticString"> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Xmx</code></span><span class="SemanticString">参数配置，若没有特别配置，将会使用默认值，详见：</span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size">Default Java 8 max heap size</a></span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size">open in new window</a></span><span class="SemanticString">)</span></span></li></ol><h2 id="https://www.notion.so/3fc1ffe331ad483582eec9dc31d29a68" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/3fc1ffe331ad483582eec9dc31d29a68"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">方法区</span></span></h2><div id="https://www.notion.so/cb59ab17ea024736b24a531b78d82b56" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。在不同的虚拟机实现上，方法区的实现是不同的。</span></span></p></div><div id="https://www.notion.so/46377ada504c455ebc0303aa4143e914" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/cad78edb791f414a8f2f083878d59f90" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</span></span></p></div><div id="https://www.notion.so/0bfc088569dc4d5ca46f3502ffb48f71" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F372b1ff3-dada-43c9-914d-37490322490e%2FUntitled.png?width=522&amp;table=block&amp;id=0bfc0885-69dc-4d5c-a46f-3502ffb48f71"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F372b1ff3-dada-43c9-914d-37490322490e%2FUntitled.png?width=522&amp;table=block&amp;id=0bfc0885-69dc-4d5c-a46f-3502ffb48f71" style="width:522px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><details id="https://www.notion.so/3d978429e4a94cb59e035f58b7def550" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">为什么要将永久代替换为元空间呢？</span></span></summary><div class="Toggle__Content"><ol class="NumberedListWrapper"><li id="https://www.notion.so/a78e1723c52c45c2b3a2e1554768e570" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">内存溢出几率更小</strong></span><span class="SemanticString">：整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</span></span></li><li id="https://www.notion.so/f648bb0f18bc43f49869462f8f13b802" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">可加载的类更多</strong></span><span class="SemanticString">：元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">MaxPermSize</code></span><span class="SemanticString">控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</span></span></li><li id="https://www.notion.so/44451f28edeb4a61b56d0e749832447a" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">JDK1.8</strong></span><span class="SemanticString">：在 JDK1.8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</span></span></li></ol></div></details><details id="https://www.notion.so/4ced34d30f86450881077b8fc609a406" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">方法区常用参数有哪些</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/c1eb6bc0f7014f1aac8e825d160c7525" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。</span></span></p></div><pre id="https://www.notion.so/7f9af5e1fc094d3faf4cfc3bd6507a2e" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span></span></code></pre><div id="https://www.notion.so/e5609bb2f4df414ca57c05298008ad24" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</span></span></p></div><div id="https://www.notion.so/d912ab38cf624f69aaccd04cf4872b8c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。下面是一些常用参数：</span></span></p></div><pre id="https://www.notion.so/cc83454378c04e26bbb2df6c1ce18e9e" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小</span></span></span></code></pre><div id="https://www.notion.so/88a12596dffd45f0ac7b340aa82278fc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</span></span></p></div></div></details><h2 id="https://www.notion.so/9a8b1a64403744a3904feff6f42db054" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/9a8b1a64403744a3904feff6f42db054"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">运行时常量池</span></span></h2><div id="https://www.notion.so/c0d76ecfae1f41609f69bf758bfa4418" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。</span></span></p></div><div id="https://www.notion.so/b35444a97eee4568af68958c775fe04f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">运行时常量池。常量池是class文件中的，当该类被加载，它的常量池信息就会 被放入运行时常量池，并把里面的符号地址变为真实地址。</span></span></p></div><div id="https://www.notion.so/3d4c51ed8f8f459d8abab9d00dfb4dd1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">OutOfMemoryError</code></span><span class="SemanticString">错误。</span></span></p></div><h2 id="https://www.notion.so/2f2d6f021d594cfbbe9ad31f7e878266" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/2f2d6f021d594cfbbe9ad31f7e878266"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">字符串常量池</span></span></h2><div id="https://www.notion.so/fc1aee76b46d4797a7734eaa5537e48b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">字符串常量池</strong></span><span class="SemanticString">是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</span></span></p></div><pre id="https://www.notion.so/da2f92f74cd849e3a7af5fa3137555de" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token comment">// 在堆中创建字符串对象”ab“</span>
<span class="token comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span>
<span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>
<span class="token comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span>
<span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aa<span class="token operator">==</span>bb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span></span></span></span></code></pre><div id="https://www.notion.so/72ddcf29e1a24189b9838906bfb9e38d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">HotSpot 虚拟机中字符串常量池的实现是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">src/hotspot/share/classfile/stringTable.cpp</code></span><span class="SemanticString"> ,</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StringTable</code></span><span class="SemanticString"> 本质上就是一个</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashSet&lt;String&gt;</code></span><span class="SemanticString"> ,容量为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StringTableSize</code></span><span class="SemanticString">（可以通过 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">-XX:StringTableSize</code></span><span class="SemanticString"> 参数来设置）。</span></span></p></div><div id="https://www.notion.so/a1abf936314d49e895098fa748d7c2be" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">StringTable</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。</strong></span></span></p></div><div id="https://www.notion.so/0418e38fd3c44c94825320573f18eb14" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</span></span></p></div><div id="https://www.notion.so/91090d9962724179834586b748877c5f" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6010fa3c-1f18-4150-9a3c-2588ea0801e1%2FUntitled.png?width=751&amp;table=block&amp;id=91090d99-6272-4179-8345-86b748877c5f"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6010fa3c-1f18-4150-9a3c-2588ea0801e1%2FUntitled.png?width=751&amp;table=block&amp;id=91090d99-6272-4179-8345-86b748877c5f" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/c32b6b6f86c5471eab84a795756c78dd" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F108d9f26-3054-463c-b1f4-3e78e2f0e1e6%2FUntitled.png?width=751&amp;table=block&amp;id=c32b6b6f-86c5-471e-ab84-a795756c78dd"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F108d9f26-3054-463c-b1f4-3e78e2f0e1e6%2FUntitled.png?width=751&amp;table=block&amp;id=c32b6b6f-86c5-471e-ab84-a795756c78dd" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><details id="https://www.notion.so/eb7405baf2e8496783d584eb519c842c" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">JDK1.7为什么要将字符串常量池移动到堆中？</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/625779eca51c432b9da4469c2a17468d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">高效回收字符串内存</strong></span><span class="SemanticString">：主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</span></span></p></div></div></details><blockquote id="https://www.notion.so/8612940b3aec4a9d86ec52416e110bf6" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</span></span></blockquote><h2 id="https://www.notion.so/8d73ae2e58cd499587174bef7f7ae0f6" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/8d73ae2e58cd499587174bef7f7ae0f6"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">直接内存</span></span></h2><div id="https://www.notion.so/bbb5e5c622ab41f591202539b60c7d96" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</span></span></p></div><div id="https://www.notion.so/92698325bac340998ec4b726459c8157" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">JDK1.4 中新加入的 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">NIO(New Input/Output) 类</strong></span><span class="SemanticString">，引入了一种基于</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">通道（Channel）</strong></span><span class="SemanticString">与</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">缓存区（Buffer）</strong></span><span class="SemanticString">的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">DirectByteBuffer</strong></span><span class="SemanticString"> 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。 </span></span></p></div><div id="https://www.notion.so/a07abdd2b8474915a64945e4d6c095ad" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</span></span></p></div><h2 id="https://www.notion.so/e7d11427fb0549f78ee9433ebb931ca2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/e7d11427fb0549f78ee9433ebb931ca2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">HotSpot堆中对象的创建、布局和访问</span></span></h2><h3 id="https://www.notion.so/b74dcf8ad7d7422f8fc3bc8751047dd2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/b74dcf8ad7d7422f8fc3bc8751047dd2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">对象的创建</span></span></h3><details id="https://www.notion.so/54b3a42ed3754480bf85908ddb985424" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">一、类加载检查</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/88da2238575f4ac186d8a55605ab96d3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">常量池</strong></span><span class="SemanticString">中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">类加载</strong></span><span class="SemanticString">过程。</span></span></p></div><div id="https://www.notion.so/f2bbfe778a5f45afb3aad1db585151f6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></div></details><details id="https://www.notion.so/e06ca7600bf64cc19bf2a3f4633cc971" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">二、分配内存</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/1626e2cc401c465ab8a650854c3b80d4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">类加载检查</strong></span><span class="SemanticString">通过后，接下来虚拟机将为新生对象</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">分配内存</strong></span><span class="SemanticString">。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">分配方式</strong></span><span class="SemanticString">有 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">“指针碰撞”</strong></span><span class="SemanticString"> 和 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">“空闲列表”</strong></span><span class="SemanticString"> 两种，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/4474169483c04355b1e736d7403b7aa6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">内存分配的两种方式</strong></span><span class="SemanticString"> （补充内容，需要掌握）：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/8bec3c8fe33e4aea9bab20b52598f339" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">指针碰撞 ：</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/1f79ee27f85e4325ac447fdcd28898d0" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">适用场合 ：堆内存规整（即没有内存碎片）的情况下。</span></span></li><li id="https://www.notion.so/9b60bc53b63840738ee01df01ab1ce82" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</span></span></li><li id="https://www.notion.so/29de28e37bff4701965d5549e438a14b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">使用该分配方式的 GC 收集器：Serial, ParNew</span></span></li></ul></li><li id="https://www.notion.so/8668b89a36784c67a74a5c7399a2ae5c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">空闲列表 ：</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/25a58f24c6cb453bbce8100cccca597a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">适用场合 ： 堆内存不规整的情况下。</span></span></li><li id="https://www.notion.so/497ba92733f6408bbb0a5f1ee248dc19" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</span></span></li><li id="https://www.notion.so/303b09bbaf2c478ab8f49c93966a0b3b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">使用该分配方式的 GC 收集器：CMS</span></span></li></ul></li></ul><div id="https://www.notion.so/e467505c16cc49a5a96b0011aafdee04" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;（也称作&quot;标记-压缩&quot;），值得注意的是，复制算法内存也是规整的。</span></span></p></div><div id="https://www.notion.so/87c7addb2b9c4560933f62f3d3dc4677" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">内存分配并发问题（补充内容，需要掌握）</strong></span></span></p></div><div id="https://www.notion.so/115b56e55dfb46319446b2391e9057b2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/23deb787c15741fcb7b7008a8beb9ba3" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">CAS+失败重试：</strong></span><span class="SemanticString"> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></span></span></li><li id="https://www.notion.so/a9ae7564c5ca4e1b8468ec332f28a1fc" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">TLAB：</strong></span><span class="SemanticString"> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</span></span></li></ul><div id="https://www.notion.so/4239ab4fa36344319dafe92dbb658435" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/9c1e4959e58141ba8c7e494ce63bfdd3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></div></details><details id="https://www.notion.so/ce3e839c380a4d018229a61c76bbdf06" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">三、初始化零值</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/c984ef8628f547a6a3291e4fee9d1c42" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</span></span></p></div></div></details><details id="https://www.notion.so/cb3734ccb6bd4410a6863389d3887aa4" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">四、设置对象头</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/a9c4905b2363459e948b9e8d2bf913c5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">初始化零值完成之后，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">虚拟机要对对象进行必要的设置</strong></span><span class="SemanticString">，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">这些信息存放在对象头中。</strong></span><span class="SemanticString">另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</span></span></p></div></div></details><details id="https://www.notion.so/5bd2f77df3b4457da8ba7b5a291c982a" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">五、执行init方法</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/a981945f42b14759bfc0cb99611b62dd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，&lt;init&gt;方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行&lt;init&gt;方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</span></span></p></div><div id="https://www.notion.so/f0933b03994f403ca8ed23c78f6b8e54" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></div></details><h3 id="https://www.notion.so/c82c86dfc7324c5697d95cbad73d5256" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/c82c86dfc7324c5697d95cbad73d5256"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">对象的内存布局</span></span></h3><div id="https://www.notion.so/15e8ffd1b1bc46f89f9043cf6c5642bd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">对象头</strong></span><span class="SemanticString">、</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">实例数据</strong></span><span class="SemanticString">和</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">对齐填充</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/1706807e59e3400e9c49e27740611ea3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Hotspot 虚拟机的对象头包括两部分信息</strong></span><span class="SemanticString">，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第一部分用于存储对象自身的运行时数据</strong></span><span class="SemanticString">（哈希码、GC 分代年龄、锁状态标志等等），</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">另一部分是类型指针</strong></span><span class="SemanticString">，即对象指向它的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">类元数据</strong></span><span class="SemanticString">的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</span></span></p></div><div id="https://www.notion.so/4ae120e5c7bd476c8edc9248e4b625fd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">实例数据部分是对象真正存储的有效信息</strong></span><span class="SemanticString">，也是在程序中所定义的各种类型的字段内容。</span></span></p></div><div id="https://www.notion.so/f6a9abed8ca84859888d87565dca1fcc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong></span><span class="SemanticString"> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</span></span></p></div><h3 id="https://www.notion.so/d01f5b7d335f4c7c8aebda696dae7345" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/d01f5b7d335f4c7c8aebda696dae7345"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">对象的访问定位</span></span></h3><div id="https://www.notion.so/678cf76add53462198361e520e53de7e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Java 程序通过栈上的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">局部变量表</strong></span><span class="SemanticString">中的 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">reference </strong></span><span class="SemanticString">数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">使用句柄</strong></span><span class="SemanticString">、</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">直接指针</strong></span><span class="SemanticString">。</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/4fc215ccd7aa492fa75078939cd76c41" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">句柄</strong></span></span><div id="https://www.notion.so/2f16183b38354431be107bdf8b405366" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息</span></span></p></div><div id="https://www.notion.so/7dfed2af9ca74593911cd95aab6a3f1e" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3410d79a-59b6-4411-96f1-52a2845232ab%2FUntitled.png?width=761&amp;table=block&amp;id=7dfed2af-9ca7-4593-911c-d95aab6a3f1e"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3410d79a-59b6-4411-96f1-52a2845232ab%2FUntitled.png?width=761&amp;table=block&amp;id=7dfed2af-9ca7-4593-911c-d95aab6a3f1e" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div></li><li id="https://www.notion.so/159ffa5ee6814cda8f3de467da01d543" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">直接指针</strong></span></span><div id="https://www.notion.so/80a1efa685c2478a966b6ffe246adc19" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果使用直接指针访问，reference中存储的直接就是对象的地址。</span></span></p></div><div id="https://www.notion.so/d0fa184353ed465da1030c63a630e49f" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F911e64b1-4cb8-4f07-bdb0-405c3768c535%2FUntitled.png?width=761&amp;table=block&amp;id=d0fa1843-53ed-465d-a103-0c63a630e49f"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F911e64b1-4cb8-4f07-bdb0-405c3768c535%2FUntitled.png?width=761&amp;table=block&amp;id=d0fa1843-53ed-465d-a103-0c63a630e49f" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div></li></ol><div id="https://www.notion.so/98e1e69b487c4ef7b5f1a9fdde67fd60" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/26aad9aaffad43488a5deaa97fa2cdb4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">稳定</strong></span><span class="SemanticString">的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">速度快</strong></span><span class="SemanticString">，它节省了一次指针定位的时间开销。</span></span></p></div><div id="https://www.notion.so/73f027dd7aa342fea932f4d96a19f34d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></article>
    <script src="https://utteranc.es/client.js"
        repo="youthtoday/youthtoday.github.io"
        issue-term="pathname"
        label="✨"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>
  <footer class="Footer">
  <div>&copy; Nick的博客 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>
