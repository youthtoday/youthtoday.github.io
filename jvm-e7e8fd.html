<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>JVM&nbsp;|&nbsp;Nick的博客</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="JVM">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="-fe1f32.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📚&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>分类</span>
        </div>
      </a>
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>关于我</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">JVM</h1>
    
      <div class="DateTagBar">
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--pink">
            <a href="tag/Java基础.html">Java基础</a>
          </span>
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--default">
            <a href="tag/JVM.html">JVM</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/e7e8fddeddbd4c70b3f3ad38d8171e6a" class="PageRoot"><h1 id="https://www.notion.so/fa295c6f9edd4c4a8002d4946c262110" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/fa295c6f9edd4c4a8002d4946c262110"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">运行时数据区域</span></span></h1><div id="https://www.notion.so/febdf2c6210a404aaab21ee82d37705e" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb355a300-e396-4eca-9e32-d4116bf5a68c%2FUntitled.png?width=1546&amp;table=block&amp;id=febdf2c6-210a-404a-aab2-1ee82d37705e"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb355a300-e396-4eca-9e32-d4116bf5a68c%2FUntitled.png?width=1546&amp;table=block&amp;id=febdf2c6-210a-404a-aab2-1ee82d37705e" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h2 id="https://www.notion.so/a5eb4588dbd546a98a3296ee7b21f333" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/a5eb4588dbd546a98a3296ee7b21f333"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">程序计数器Program Counter Register</span></span></h2><div id="https://www.notion.so/ccf05d38c3cf4321b4305eedf7924c80" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0d9f8fa7-6763-4059-ab58-2ad5447ccde0%2FUntitled.png?width=1384&amp;table=block&amp;id=ccf05d38-c3cf-4321-b430-5eedf7924c80"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0d9f8fa7-6763-4059-ab58-2ad5447ccde0%2FUntitled.png?width=1384&amp;table=block&amp;id=ccf05d38-c3cf-4321-b430-5eedf7924c80" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/3ccf233c05a64facbc22de36fbefd0e7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器，存储了下一行字节码的地址。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。</span></span></p></div><div id="https://www.notion.so/4bd3442195444b63b863ed802b2400a8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</span></span></p></div><div id="https://www.notion.so/12e6708c4db4404c987d907a340405f5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所以程序计数器主要有两个</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">作用</strong></span><span class="SemanticString">：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/453390de44e44afb99661803dfd10064" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</span></span></li><li id="https://www.notion.so/3e613dc8e9c14976a12cb69b7edadd6a" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</span></span></li></ol><div id="https://www.notion.so/0a57f22efb8f4f37bdf6113d7cc0bff6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">注意 ：程序计数器是唯一一个不会出现 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">OutOfMemoryError</code></span><span class="SemanticString"> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</span></span></p></div><h2 id="https://www.notion.so/1f8f8588c8b44acf841739aca5f03293" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/1f8f8588c8b44acf841739aca5f03293"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">虚拟机栈Virtual Machine Stacks</span></span></h2><div id="https://www.notion.so/193f4f653301461c9f9eec726855b93e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">每个线程运行时需要的内存，称为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">虚拟机栈</strong></span></span></p></div><div id="https://www.notion.so/0a9baea59bbf445e85f26169e57b660b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">每个栈由多个</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">栈帧</strong></span><span class="SemanticString">组成，对应着每次方法调用时所占用的内存</span></span></p></div><div id="https://www.notion.so/f379c981a530428ca8a6636b97b8fdae" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">每个线程只有一个</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">活动栈帧</strong></span><span class="SemanticString">，对应着当前正在执行的方法</span></span></p></div><div id="https://www.notion.so/57a65be737d8466991329607cbf8bcb9" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F40cd9c37-26a1-4b50-a77d-5ff6b2e05325%2FUntitled.png?width=780&amp;table=block&amp;id=57a65be7-37d8-4669-9132-9607cbf8bcb9"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F40cd9c37-26a1-4b50-a77d-5ff6b2e05325%2FUntitled.png?width=780&amp;table=block&amp;id=57a65be7-37d8-4669-9132-9607cbf8bcb9" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><details id="https://www.notion.so/c917981f51574a6996ebf022b534dd4b" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">栈内存分配越大越好吗？</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/924fd78528534b4ca3161f2957ade109" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">不是，栈内存分配越大，则线程数会减少，CPU效率降低。</span></span></p></div></div></details><details id="https://www.notion.so/3eb378dc3f684f549c6447fdd99a9d0b" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">方法内的局部变量是否线程安全？</span></span></summary><div class="Toggle__Content"><ul class="BulletedListWrapper"><li id="https://www.notion.so/fcf02aa4c9ef418b86284bb77c9161ff" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</span></span></li><li id="https://www.notion.so/21882430fcfc4249b2e28f46c642fdae" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</span></span></li></ul></div></details><h3 id="https://www.notion.so/e2a4671f03ff4143839725c8bc8869eb" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e2a4671f03ff4143839725c8bc8869eb"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">两种可能报错</span></span></h3><div id="https://www.notion.so/57e8e898df0a47409aa0d859eed524ce" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StackOverFlowError</code></span><span class="SemanticString"> 错误。</span></span></p></div><div id="https://www.notion.so/c09bedc70aa14022b3b36acb5edff514" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></span></span></p></div><div id="https://www.notion.so/e8d549f202df42b9bdbd4b4bca0ed4b7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">除了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StackOverFlowError</code></span><span class="SemanticString"> 错误之外，栈还可能会出现</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">OutOfMemoryError</code></span><span class="SemanticString">错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">OutOfMemoryError</code></span><span class="SemanticString">异常。</span></span></p></div><div id="https://www.notion.so/f0c61f74b6714fddb410709319ab67dc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">简单总结一下程序运行中栈可能会出现两种错误：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/3f0e8bddaecc44519752d1b78a63b665" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">StackOverFlowError</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">：</strong></span><span class="SemanticString"> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StackOverFlowError</code></span><span class="SemanticString"> 错误。</span></span></li><li id="https://www.notion.so/3a94679d837d40b3b6320a643d86191f" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">OutOfMemoryError</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">：</strong></span><span class="SemanticString"> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">OutOfMemoryError</code></span><span class="SemanticString">异常。</span></span></li></ul><h2 id="https://www.notion.so/c36ec18769ae48bcbac09bf38985c2c3" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/c36ec18769ae48bcbac09bf38985c2c3"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">本地方法栈Native Method Stacks</span></span></h2><div id="https://www.notion.so/6f34a54cd2ad498e9dfedf41a2dfc329" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">和虚拟机栈所发挥的作用非常相似，区别是： </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong></span><span class="SemanticString">比如hashCode，notify，wait都是本地方法。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</span></span></p></div><div id="https://www.notion.so/9ca6be24831a4b9887c414ae718e0d2c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</span></span></p></div><div id="https://www.notion.so/46497ab7ea9044be999bf684df4ead5f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StackOverFlowError</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">OutOfMemoryError</code></span><span class="SemanticString"> 两种错误。</span></span></p></div><h2 id="https://www.notion.so/89961bf5b11b4780bed41a244ff0614c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/89961bf5b11b4780bed41a244ff0614c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">堆Heap</span></span></h2><div id="https://www.notion.so/849325963d1c4a72a6ad5d5828783877" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">堆是JVM所管理的内存中最大的一块，是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的是存放对象实习。几乎所有的对象实例及数组都在堆里分配内存。</span></span></p></div><div id="https://www.notion.so/8265b584fadc495b80b6ef91bd752ed4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</span></span></p></div><div id="https://www.notion.so/054324dd9dad484d8a4e988d234b353a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Java 堆是垃圾收集器管理的主要区域，因此也被称作 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">GC 堆（Garbage Collected Heap）</strong></span><span class="SemanticString">。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</span></span></p></div><div id="https://www.notion.so/a2909f5bd42f4928938879aa9ee5167f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/2f17c522601647258d8a819cd5c96e2b" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">新生代内存(Young Generation)</span></span></li><li id="https://www.notion.so/71bd1ed247f94aaeb1d6260e28615c5b" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">老生代(Old Generation)</span></span></li><li id="https://www.notion.so/b44673c41b3e4ad891d7064da6312175" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">永久代(Permanent Generation)</span></span></li></ol><div id="https://www.notion.so/4989e68f27944a66b420bded44f18592" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</span></span></p></div><div id="https://www.notion.so/3deb337186a740578d7eca45d4ba5f2b" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6af2a6d9-3fd0-4b90-bed2-7d9634436fae%2FUntitled.png?width=871&amp;table=block&amp;id=3deb3371-86a7-4057-8d7e-ca45d4ba5f2b"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6af2a6d9-3fd0-4b90-bed2-7d9634436fae%2FUntitled.png?width=871&amp;table=block&amp;id=3deb3371-86a7-4057-8d7e-ca45d4ba5f2b" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/3d78e534dffa4559a027c933d2004a0b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong></span><span class="SemanticString"> （我会在方法区这部分内容详细介绍到）。</span></span></p></div><div id="https://www.notion.so/7c1adb8bbe4d4277ab0cff5e718555fa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">-XX:MaxTenuringThreshold</code></span><span class="SemanticString"> 来设置。</span></span></p></div><div id="https://www.notion.so/412ecf539bd1486da9fb6cbfeb172c88" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">堆这里最容易出现的就是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">OutOfMemoryError</code></span><span class="SemanticString"> 错误，并且出现这种错误之后的表现形式还会有几种，比如：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/c6851cd50b8e4c2a96963c6b179091ee" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</strong></code></span><span class="SemanticString"> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</span></span></li><li id="https://www.notion.so/e872bbcfd71b4571824e6a466e516464" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">java.lang.OutOfMemoryError: Java heap space</strong></code></span><span class="SemanticString"> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Xmx</code></span><span class="SemanticString">参数配置，若没有特别配置，将会使用默认值，详见：</span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size">Default Java 8 max heap size</a></span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size">open in new window</a></span><span class="SemanticString">)</span></span></li></ol><h2 id="https://www.notion.so/3fc1ffe331ad483582eec9dc31d29a68" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/3fc1ffe331ad483582eec9dc31d29a68"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">方法区</span></span></h2><div id="https://www.notion.so/cb59ab17ea024736b24a531b78d82b56" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。在不同的虚拟机实现上，方法区的实现是不同的。</span></span></p></div><div id="https://www.notion.so/46377ada504c455ebc0303aa4143e914" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/cad78edb791f414a8f2f083878d59f90" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</span></span></p></div><div id="https://www.notion.so/0bfc088569dc4d5ca46f3502ffb48f71" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F372b1ff3-dada-43c9-914d-37490322490e%2FUntitled.png?width=522&amp;table=block&amp;id=0bfc0885-69dc-4d5c-a46f-3502ffb48f71"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F372b1ff3-dada-43c9-914d-37490322490e%2FUntitled.png?width=522&amp;table=block&amp;id=0bfc0885-69dc-4d5c-a46f-3502ffb48f71" style="width:522px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><details id="https://www.notion.so/3d978429e4a94cb59e035f58b7def550" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">为什么要将永久代替换为元空间呢？</span></span></summary><div class="Toggle__Content"><ol class="NumberedListWrapper"><li id="https://www.notion.so/a78e1723c52c45c2b3a2e1554768e570" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">内存溢出几率更小</strong></span><span class="SemanticString">：整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</span></span></li><li id="https://www.notion.so/f648bb0f18bc43f49869462f8f13b802" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">可加载的类更多</strong></span><span class="SemanticString">：元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">MaxPermSize</code></span><span class="SemanticString">控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</span></span></li><li id="https://www.notion.so/44451f28edeb4a61b56d0e749832447a" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">JDK1.8</strong></span><span class="SemanticString">：在 JDK1.8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</span></span></li></ol></div></details><details id="https://www.notion.so/4ced34d30f86450881077b8fc609a406" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">方法区常用参数有哪些</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/c1eb6bc0f7014f1aac8e825d160c7525" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。</span></span></p></div><pre id="https://www.notion.so/7f9af5e1fc094d3faf4cfc3bd6507a2e" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span></span></code></pre><div id="https://www.notion.so/e5609bb2f4df414ca57c05298008ad24" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</span></span></p></div><div id="https://www.notion.so/d912ab38cf624f69aaccd04cf4872b8c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。下面是一些常用参数：</span></span></p></div><pre id="https://www.notion.so/cc83454378c04e26bbb2df6c1ce18e9e" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小</span></span></span></code></pre><div id="https://www.notion.so/88a12596dffd45f0ac7b340aa82278fc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</span></span></p></div></div></details><h2 id="https://www.notion.so/9a8b1a64403744a3904feff6f42db054" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/9a8b1a64403744a3904feff6f42db054"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">运行时常量池</span></span></h2><div id="https://www.notion.so/c0d76ecfae1f41609f69bf758bfa4418" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></article>
    <script src="https://utteranc.es/client.js"
        repo="youthtoday/youthtoday.github.io"
        issue-term="pathname"
        label="✨"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>
  <footer class="Footer">
  <div>&copy; Nick的博客 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>
