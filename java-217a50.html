<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>Java集合&nbsp;|&nbsp;Nick的博客</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="Java集合">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="-fe1f32.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📚&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>分类</span>
        </div>
      </a>
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>关于我</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">Java集合</h1>
    
      <div class="DateTagBar">
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--default">
            <a href="tag/Java集合.html">Java集合</a>
          </span>
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--pink">
            <a href="tag/Java基础.html">Java基础</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/217a506def3d4c11b4575703033ff456" class="PageRoot"><h1 id="https://www.notion.so/62f21f5d106b4c7aa9fd46d3a927bd93" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/62f21f5d106b4c7aa9fd46d3a927bd93"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">集合概览</span></span></h1><div id="https://www.notion.so/cc6f59524a554c0583a2985912a67201" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Java集合，也叫容器。又两大接口派生而来：Collection接口（单列集合）、Map接口（双列集合）。对于Collection接口，下面又有三个主要的子接口：List、Set、Queue。</span></span></p></div><div id="https://www.notion.so/72e9cbeb16a440a7a505d5cf3a586cc1" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F477ff298-2c26-4802-a97a-092b0bd18d61%2FUntitled.png?width=1612&amp;table=block&amp;id=72e9cbeb-16a4-40a7-a505-d5cf3a586cc1"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F477ff298-2c26-4802-a97a-092b0bd18d61%2FUntitled.png?width=1612&amp;table=block&amp;id=72e9cbeb-16a4-40a7-a505-d5cf3a586cc1" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h2 id="https://www.notion.so/281010a188e3416e974d17f7174f00a3" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/281010a188e3416e974d17f7174f00a3"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">说说 List, Set, Queue, Map 四者的区别？</span></span></h2><ul class="BulletedListWrapper"><li id="https://www.notion.so/e4091b8681c24e5980ceca7b9665f982" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">List</code></span><span class="SemanticString">(对付顺序的好帮手): 存储的元素是有序的、可重复的。</span></span></li><li id="https://www.notion.so/741404653c6b41c1b5293f824264be47" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Set</code></span><span class="SemanticString">(注重独一无二的性质): 存储的元素是无序的、不可重复的。</span></span></li><li id="https://www.notion.so/8d83dbee9873463f88d666ce11c35a3d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Queue</code></span><span class="SemanticString">(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</span></span></li></ul><div id="https://www.notion.so/5c50a71907024f78949cc7511a4da2cd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/b99ec9ed99ac43a7b2dd2460f69f1353" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Map</code></span><span class="SemanticString">(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，&quot;x&quot; 代表 key，&quot;y&quot; 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</span></span></li></ul><h3 id="https://www.notion.so/265ac5ffccbd4f819674f5e0ea86dcc1" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/265ac5ffccbd4f819674f5e0ea86dcc1"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">集合框架底层数据结构总结</span></span></h3><div id="https://www.notion.so/a896b26c1ed148bebc27a3bbd7335254" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">先来看一下 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Collection</code></span><span class="SemanticString"> 接口下面的集合。</span></span></p></div><h3 id="https://www.notion.so/1ac0ce17404d402a954ee4dc168a8295" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/1ac0ce17404d402a954ee4dc168a8295"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">List</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/60981b1bcc704f8ca63550d11ae76c24" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayList</code></span><span class="SemanticString">： </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Object[]</code></span><span class="SemanticString"> 数组</span></span></li><li id="https://www.notion.so/f9ee0cb1f56a43b99214dd8d42debf6d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Vector</code></span><span class="SemanticString">：</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Object[]</code></span><span class="SemanticString"> 数组</span></span></li><li id="https://www.notion.so/be3459e5383b417992f47197bc44fa50" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedList</code></span><span class="SemanticString">： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</span></span></li></ul><h3 id="https://www.notion.so/42bdc75e1bce484387a1333d85a5d39f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/42bdc75e1bce484387a1333d85a5d39f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Set</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/14b01fc4374a412eb4281343d9e699de" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashSet</code></span><span class="SemanticString">(无序，唯一): 基于 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 实现的，底层采用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 来保存元素</span></span></li><li id="https://www.notion.so/17afe0d72c2b4e869b3f7ce24bc75abb" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedHashSet</code></span><span class="SemanticString">: </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedHashSet</code></span><span class="SemanticString"> 是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashSet</code></span><span class="SemanticString"> 的子类，并且其内部是通过 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedHashMap</code></span><span class="SemanticString"> 来实现的。有点类似于我们之前说的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedHashMap</code></span><span class="SemanticString"> 其内部是基于 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 实现一样，不过还是有一点点区别的</span></span></li><li id="https://www.notion.so/0a8760d01f0740338e175c07d5528875" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TreeSet</code></span><span class="SemanticString">(有序，唯一): 红黑树(自平衡的排序二叉树)</span></span></li></ul><h3 id="https://www.notion.so/0890874c1af04d3e96c97f4f0c78e3f6" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/0890874c1af04d3e96c97f4f0c78e3f6"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Queue</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/b371549472fe4c1eaa3d23f957ed528a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">PriorityQueue</code></span><span class="SemanticString">: </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Object[]</code></span><span class="SemanticString"> 数组来实现二叉堆</span></span></li><li id="https://www.notion.so/500cd1578fc44e8cb650df40bc94c5f3" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayQueue</code></span><span class="SemanticString">: </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Object[]</code></span><span class="SemanticString"> 数组 + 双指针</span></span></li></ul><div id="https://www.notion.so/96fe35553c5946f99df21080fee35bc8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">再来看看 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Map</code></span><span class="SemanticString"> 接口下面的集合。</span></span></p></div><h3 id="https://www.notion.so/63535eb26cb7411c92ac3cbd245b3c54" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/63535eb26cb7411c92ac3cbd245b3c54"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Map</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/50c2f86dd962457699123e3ba3eeaea4" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString">： JDK1.8 之前 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 由数组+链表组成的，数组是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</span></span></li><li id="https://www.notion.so/6d97646d4a694855b5ec65cfa789fcad" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedHashMap</code></span><span class="SemanticString">： </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedHashMap</code></span><span class="SemanticString"> 继承自 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString">，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedHashMap</code></span><span class="SemanticString"> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：</span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》</a></span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://www.imooc.com/article/22931">open in new window</a></span></span></li><li id="https://www.notion.so/b4087c68dbe54a56b0b0292200ff6b45" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Hashtable</code></span><span class="SemanticString">： 数组+链表组成的，数组是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Hashtable</code></span><span class="SemanticString"> 的主体，链表则是主要为了解决哈希冲突而存在的</span></span></li><li id="https://www.notion.so/944962d2a0f84a05a2d7e769143aa8ae" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TreeMap</code></span><span class="SemanticString">： 红黑树（自平衡的排序二叉树）</span></span></li></ul><h3 id="https://www.notion.so/7d0b3fa3cb3243c7ab488c687aaf7b68" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/7d0b3fa3cb3243c7ab488c687aaf7b68"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">为什么要使用集合？</span></span></h3><div id="https://www.notion.so/ab2f35f4f19a4ccfa1648733dfa84fe9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</span></span></p></div><div id="https://www.notion.so/e24cf5834705427a8f2f4d90816a41b1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</span></span></p></div><h1 id="https://www.notion.so/ad32650960364325a3bad90e6ea7ec21" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/ad32650960364325a3bad90e6ea7ec21"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Collection 子接口之 List</span></span></h1><h3 id="https://www.notion.so/c3f93ff8ba694ea5881a6e3bf98e0bf7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/c3f93ff8ba694ea5881a6e3bf98e0bf7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ArrayList 和 Vector 的区别?</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/629cf510c0464cb6b9ecb800a2f12e22" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayList</code></span><span class="SemanticString"> 是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">List</code></span><span class="SemanticString"> 的主要实现类，底层使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Object[]</code></span><span class="SemanticString">存储，适用于频繁的查找工作，线程不安全 ；</span></span></li><li id="https://www.notion.so/1b2f056a5eb44f85bef6ffe8b6c18def" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Vector</code></span><span class="SemanticString"> 是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">List</code></span><span class="SemanticString"> 的古老实现类，底层使用</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Object[]</code></span><span class="SemanticString"> 存储，线程安全的。</span></span></li></ul><h3 id="https://www.notion.so/f77c1f8fce2e45829e3ed805dba76694" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/f77c1f8fce2e45829e3ed805dba76694"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ArrayList 与 LinkedList 区别?</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/967d6d21c6c24f9ba4ff23481b0aa89e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">是否保证线程安全：</strong></span><span class="SemanticString"> </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayList</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedList</code></span><span class="SemanticString"> 都是不同步的，也就是不保证线程安全；</span></span></li><li id="https://www.notion.so/4779ad3c31bf47ef868930e0026b8c51" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">底层数据结构：</strong></span><span class="SemanticString"> </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayList</code></span><span class="SemanticString"> 底层使用的是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Object</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 数组</strong></span><span class="SemanticString">；</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedList</code></span><span class="SemanticString"> 底层使用的是 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">双向链表</strong></span><span class="SemanticString"> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</span></span></li><li id="https://www.notion.so/50c4bd6b70fb4c80a05170a10314ca04" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">插入和删除是否受元素位置的影响：</strong></span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/9ef168b01b6942618ab587b5a2184f42" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayList</code></span><span class="SemanticString"> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">add(E e)</code></span><span class="SemanticString">方法的时候， </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayList</code></span><span class="SemanticString"> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">add(int index, E element)</code></span><span class="SemanticString">）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</span></span></li><li id="https://www.notion.so/40378b6a96e040148f43e0b17f557aa0" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedList</code></span><span class="SemanticString"> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">add(E e)</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">addFirst(E e)</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">addLast(E e)</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">removeFirst()</code></span><span class="SemanticString"> 、 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">removeLast()</code></span><span class="SemanticString">），时间复杂度为 O(1)，如果是要在指定位置 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">i</code></span><span class="SemanticString"> 插入和删除元素的话（</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">add(int index, E element)</code></span><span class="SemanticString">，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">remove(Object o)</code></span><span class="SemanticString">）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。</span></span></li></ul></li><li id="https://www.notion.so/1987145af6a3423081624023a48babc6" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">是否支持快速随机访问：</strong></span><span class="SemanticString"> </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedList</code></span><span class="SemanticString"> 不支持高效的随机元素访问，而 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayList</code></span><span class="SemanticString">（实现了RandomAccess接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">get(int index)</code></span><span class="SemanticString">方法)。</span></span></li><li id="https://www.notion.so/fd9924c8dfbb41a1b773ca173af26a94" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">内存空间占用：</strong></span><span class="SemanticString"> </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayList</code></span><span class="SemanticString"> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</span></span></li></ul><div id="https://www.notion.so/7b6a96bccd7f4517b3e8c2cb389cbd8d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们在项目中一般是不会使用到 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedList</code></span><span class="SemanticString"> 的，需要用到 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedList</code></span><span class="SemanticString"> 的场景几乎都可以使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayList</code></span><span class="SemanticString"> 来代替，并且，性能通常会更好！</span></span></p></div><h2 id="https://www.notion.so/9e56f119101c49ec8c67a0ce9a4f0251" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/9e56f119101c49ec8c67a0ce9a4f0251"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Collection 子接口之 Set</span></span></h2><h3 id="https://www.notion.so/5a25f18922a84e67ab71af6da17bc930" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/5a25f18922a84e67ab71af6da17bc930"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="#https://www.notion.so/c">#</a></span><span class="SemanticString"> comparable 和 Comparator 的区别</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/e049ae0f715c4e89afc023b86e932787" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">comparable</code></span><span class="SemanticString"> 接口实际上是出自</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">java.lang</code></span><span class="SemanticString">包 它有一个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">compareTo(Object obj)</code></span><span class="SemanticString">方法用来排序</span></span></li><li id="https://www.notion.so/3c56ca867e0d45b8bc9fd433c4bc539f" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">comparator</code></span><span class="SemanticString">接口实际上是出自 java.util 包它有一个</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">compare(Object obj1, Object obj2)</code></span><span class="SemanticString">方法用来排序</span></span></li></ul><div id="https://www.notion.so/d7a556e5f7c54ae6b5b591205ae8c3f5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">实现了comparable接口的类可以重写compareTo方法，来自定义排序规则</span></span></p></div><div id="https://www.notion.so/644536fb735a49478fcbde79a8ceee67" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">对于Collections的sort方法可以重写Comparator中的compare方法，来自定义排序规则</span></span></p></div><h3 id="https://www.notion.so/7dd67366a80946f587e30a81e1cc2e84" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/7dd67366a80946f587e30a81e1cc2e84"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">无序性和不可重复性的含义是什么</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/47fd7f375f7344dc8e8e9894b3ec935a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</span></span></li><li id="https://www.notion.so/fa23b47f23ef4b8ead13e97a95d2a262" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">不可重复性是指添加的元素按照 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">equals()</code></span><span class="SemanticString"> 判断时 ，返回 false，需要同时重写 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">equals()</code></span><span class="SemanticString"> 方法和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">hashCode()</code></span><span class="SemanticString"> 方法。</span></span></li></ul><h3 id="https://www.notion.so/a7a15032f7e343cdafe83e49c3eab0d1" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/a7a15032f7e343cdafe83e49c3eab0d1"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/7eaf7e08cfc64bfe8d131d54717ea461" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">相同：都是 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Set</code></strong></span><span class="SemanticString"> 接口的实现类，都能保证</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">元素唯一</strong></span><span class="SemanticString">，并且都</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不是线程安全</strong></span><span class="SemanticString">的。</span></span></li><li id="https://www.notion.so/f5b1ed2dbd54450fb8dcc47415b55c35" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">底层数据结构不同：</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/f7348c2bb21d4820a6dc649994b0ff72" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashSet</code></span><span class="SemanticString"> 的底层数据结构是哈希表（基于 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 实现）。</span></span></li><li id="https://www.notion.so/bf11cf506c0941209be5a4a0590b221b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedHashSet</code></span><span class="SemanticString"> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。</span></span></li><li id="https://www.notion.so/d5298aa8c789489eb65704369cf054cc" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TreeSet</code></span><span class="SemanticString"> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</span></span></li></ul></li><li id="https://www.notion.so/0db3c3fb1c0b4e62ace58c2d7c05c52e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">应用场景不同：</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/9afe259140bc46a4b9dd193c68b4154b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashSet</code></span><span class="SemanticString"> 用于不需要保证元素插入和取出顺序的场景</span></span></li><li id="https://www.notion.so/c12f6325de814aa0a6496b7b4741efa6" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedHashSet</code></span><span class="SemanticString"> 用于保证元素的插入和取出顺序满足 FIFO 的场景</span></span></li><li id="https://www.notion.so/06c02e16d6e14635849730e7c7e953fc" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TreeSet</code></span><span class="SemanticString"> 用于支持对元素自定义排序规则的场景</span></span></li></ul></li></ul><h1 id="https://www.notion.so/3ba97add3bf547b1b6283cf5092ddd27" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/3ba97add3bf547b1b6283cf5092ddd27"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Collection 子接口之 Queue</span></span></h1><h3 id="https://www.notion.so/09806d91c9744e93b942f646d0837651" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/09806d91c9744e93b942f646d0837651"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Queue 与 Deque 的区别</span></span></h3><div id="https://www.notion.so/2776d1dd56964d648479e1d4e03e1931" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Queue</code></span><span class="SemanticString"> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">先进先出（FIFO）</strong></span><span class="SemanticString"> 规则。</span></span></p></div><div id="https://www.notion.so/3c8b4715f33b4283a5f5c86f0c3ea46a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Queue</code></span><span class="SemanticString"> 扩展了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Collection</code></span><span class="SemanticString"> 的接口，根据 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">因为容量问题而导致操作失败后处理方式的不同</strong></span><span class="SemanticString"> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</span></span></p></div><div><div></div><div></div><div></div><div></div></div><div id="https://www.notion.so/10d0d3a1d58046e99f039cea73763b0e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Deque</code></span><span class="SemanticString"> 是双端队列，在队列的两端均可以插入或删除元素。</span></span></p></div><div id="https://www.notion.so/c4db8469c8794a3ebda636eff53b54d7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Deque</code></span><span class="SemanticString"> 扩展了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Queue</code></span><span class="SemanticString"> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</span></span></p></div><div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div><div id="https://www.notion.so/9e2c2757265744df9f46acb0881bd72e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">事实上，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Deque</code></span><span class="SemanticString"> 还提供有 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">push()</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">pop()</code></span><span class="SemanticString"> 等其他方法，可用于模拟栈。</span></span></p></div><h3 id="https://www.notion.so/7bfbbcfbe6654909a7914fd959100a46" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/7bfbbcfbe6654909a7914fd959100a46"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ArrayDeque 与 LinkedList 的区别</span></span></h3><div id="https://www.notion.so/f8754ed258bb415ea1784ac269bdc64e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayDeque</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedList</code></span><span class="SemanticString"> 都实现了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Deque</code></span><span class="SemanticString"> 接口，两者都具有队列的功能，但两者有什么区别呢？</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/c0aae3e2653d4300a10aff743fce40a4" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayDeque</code></span><span class="SemanticString"> 是基于可变长的数组和双指针来实现，而 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedList</code></span><span class="SemanticString"> 则通过链表来实现。</span></span></li><li id="https://www.notion.so/5b58a78391f94daebd9ff1014ac69d62" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayDeque</code></span><span class="SemanticString"> 不支持存储 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">NULL</code></span><span class="SemanticString"> 数据，但 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedList</code></span><span class="SemanticString"> 支持。</span></span></li><li id="https://www.notion.so/50d20d8c367a447d9ca0f68edbc41e82" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayDeque</code></span><span class="SemanticString"> 是在 JDK1.6 才被引入的，而</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedList</code></span><span class="SemanticString"> 早在 JDK1.2 时就已经存在。</span></span></li><li id="https://www.notion.so/096550b109b24bff85d102e459874149" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayDeque</code></span><span class="SemanticString"> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedList</code></span><span class="SemanticString"> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</span></span></li></ul><div id="https://www.notion.so/cb1c8bb4a55e4aac81208bc3d55ecf42" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">从性能的角度上，选用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayDeque</code></span><span class="SemanticString"> 来实现队列要比 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedList</code></span><span class="SemanticString"> 更好。此外，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ArrayDeque</code></span><span class="SemanticString"> 也可以用于实现栈。</span></span></p></div><h3 id="https://www.notion.so/a22c5229bd374fe4870b50ef4d295e94" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/a22c5229bd374fe4870b50ef4d295e94"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">说一说 PriorityQueue</strong></strong></span></span></h3><div id="https://www.notion.so/4ec908c919574bf08da726962adfaa0b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">PriorityQueue</code></span><span class="SemanticString"> 是在 JDK1.5 中被引入的, 其与 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Queue</code></span><span class="SemanticString"> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</span></span></p></div><div id="https://www.notion.so/98943a45d94a447286a8ddf7d1b8aabd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这里列举其相关的一些要点：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/3067186d15b94fddbd6f6c92794e1f33" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">PriorityQueue</code></span><span class="SemanticString"> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</span></span></li><li id="https://www.notion.so/2b21073ba41643e58b67d409f5e49685" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">PriorityQueue</code></span><span class="SemanticString"> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</span></span></li><li id="https://www.notion.so/33985577d23e46eda9a46d2276656255" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">PriorityQueue</code></span><span class="SemanticString"> 是非线程安全的，且不支持存储 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">NULL</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">non-comparable</code></span><span class="SemanticString"> 的对象。</span></span></li><li id="https://www.notion.so/7029109af24c459980d195cc10096b36" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">PriorityQueue</code></span><span class="SemanticString"> 默认是小顶堆，但可以接收一个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Comparator</code></span><span class="SemanticString"> 作为构造参数，从而来自定义元素优先级的先后。</span></span></li></ul><h2 id="https://www.notion.so/a85838e30c32470baef5cb3bd932d28b" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/a85838e30c32470baef5cb3bd932d28b"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Map 接口</span></span></h2><h3 id="https://www.notion.so/45e9b5df8de7429d92e5262a992d7267" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/45e9b5df8de7429d92e5262a992d7267"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">HashMap 和 Hashtable 的区别</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/ca43b20a5bfc421eb718ad9f00effb77" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">线程是否安全：</strong></span><span class="SemanticString"> </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 是非线程安全的，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Hashtable</code></span><span class="SemanticString"> 是线程安全的,因为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Hashtable</code></span><span class="SemanticString"> 内部的方法基本都经过</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 修饰。（如果你要保证线程安全的话就使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ConcurrentHashMap</code></span><span class="SemanticString"> 吧！）；</span></span></li><li id="https://www.notion.so/b5b4a0e077584b4f8c092f5794ea87d8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">效率：</strong></span><span class="SemanticString"> 因为线程安全的问题，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 要比 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Hashtable</code></span><span class="SemanticString"> 效率高一点。另外，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Hashtable</code></span><span class="SemanticString"> 基本被淘汰，不要在代码中使用它；</span></span></li><li id="https://www.notion.so/501bbf9e2af04401a36237a4fd0092cb" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">对 Null key 和 Null value 的支持：</strong></span><span class="SemanticString"> </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">NullPointerException</code></span><span class="SemanticString">。</span></span></li><li id="https://www.notion.so/d84ecdc59e1a4703a92e5c3216855c00" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">初始容量大小和每次扩充容量大小的不同 ：</strong></span><span class="SemanticString"> ① 创建时如果不指定容量初始值，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Hashtable</code></span><span class="SemanticString"> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Hashtable</code></span><span class="SemanticString"> 会直接使用你给定的大小，而 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 会将其扩充为 2 的幂次方大小（</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 中的</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">tableSizeFor()</code></span><span class="SemanticString">方法保证，下面给出了源代码）。也就是说 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</span></span></li><li id="https://www.notion.so/af0872c8695643cdb139aa8e71994a24" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">底层数据结构：</strong></span><span class="SemanticString"> JDK1.8 以后的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Hashtable</code></span><span class="SemanticString"> 没有这样的机制。</span></span></li></ul><h3 id="https://www.notion.so/a5ac07396c4549848025c6cbed415349" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/a5ac07396c4549848025c6cbed415349"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">HashMap 和 HashSet 区别</span></span></h3><div id="https://www.notion.so/88fdf9cd31bf466a86a5f30cbf0018ac" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果你看过 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashSet</code></span><span class="SemanticString"> 源码的话就应该知道：</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashSet</code></span><span class="SemanticString"> 底层就是基于 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 实现的。（</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashSet</code></span><span class="SemanticString"> 的源码非常非常少，因为除了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">clone()</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">writeObject()</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">readObject()</code></span><span class="SemanticString">是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashSet</code></span><span class="SemanticString"> 自己不得不实现之外，其他方法都是直接调用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 中的方法。</span></span></p></div><div><div></div><div></div><div></div><div></div><div></div></div><h3 id="https://www.notion.so/72800a7ea96a4384ba43c91e925f114f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/72800a7ea96a4384ba43c91e925f114f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">HashMap 和 TreeMap 区别</span></span></h3><div id="https://www.notion.so/6b43deebeb394e9e91af51a06ae25063" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TreeMap</code></span><span class="SemanticString"> 和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 都继承自</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">AbstractMap</code></span><span class="SemanticString"> ，但是需要注意的是</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TreeMap</code></span><span class="SemanticString">它还实现了</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">NavigableMap</code></span><span class="SemanticString">接口和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SortedMap</code></span><span class="SemanticString"> 接口。</span></span></p></div><div id="https://www.notion.so/ed7d91fdb55a4a7b8d2a6a24b91108cf" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">实现 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">NavigableMap</code></span><span class="SemanticString"> 接口让 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TreeMap</code></span><span class="SemanticString"> 有了对集合内元素的搜索的能力。</span></span></p></div><div id="https://www.notion.so/855e52d301a9467bb3c5d628ef811d74" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">实现</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SortedMap</code></span><span class="SemanticString">接口让 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TreeMap</code></span><span class="SemanticString"> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</span></span></p></div><h3 id="https://www.notion.so/5b9e151be52b4f1eb262be6a8c2fd25c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/5b9e151be52b4f1eb262be6a8c2fd25c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">HashSet 如何检查重复?</strong></strong></span></span></h3><div id="https://www.notion.so/70fa3d782b884e97bc985c5c10b0568c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</span></span></p></div><div id="https://www.notion.so/fef2911d063a49ceb4152d1e47768416" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 JDK1.8 中，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashSet</code></span><span class="SemanticString">的</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">add()</code></span><span class="SemanticString">方法只是简单的调用了</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString">的</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">put()</code></span><span class="SemanticString">方法，并且判断了一下返回值以确保是否有重复元素。在 JDK1.8 中，实际上无论</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashSet</code></span><span class="SemanticString">中是否已经存在了某元素，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashSet</code></span><span class="SemanticString">都会直接插入，只是会在</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">add()</code></span><span class="SemanticString">方法的返回值处告诉我们插入前是否存在相同元素。</span></span></p></div><h3 id="https://www.notion.so/19e4d581c4154ea5bd97d54fc55a8d26" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/19e4d581c4154ea5bd97d54fc55a8d26"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">HashMap 的底层实现</span></span></h3><h3 id="https://www.notion.so/efcc207f56234b7296e3b3a350892bfb" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/efcc207f56234b7296e3b3a350892bfb"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">JDK1.7</span></span></h3><div id="https://www.notion.so/11101145c2324b2bb14c5fcae3bbaafa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">JDK1.8 之前 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 底层是 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">数组和链表</strong></span><span class="SemanticString"> 结合在一起使用也就是 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">链表散列</strong></span><span class="SemanticString">。HashMap 通过 key 的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">hashcode</code></span><span class="SemanticString"> 经过扰动函数处理过后得到 hash 值，然后通过 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(n - 1) &amp; hash</code></span><span class="SemanticString"> (二进制取模运算)判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</span></span></p></div><div id="https://www.notion.so/292fef63c918439ab754d12720e3368b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所谓扰动函数指的就是 HashMap 的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">hash</code></span><span class="SemanticString"> 方法。使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">hash</code></span><span class="SemanticString"> 方法也就是扰动函数是为了防止一些实现比较差的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">hashCode()</code></span><span class="SemanticString"> 方法 换句话说使用扰动函数之后可以减少碰撞。</span></span></p></div><div id="https://www.notion.so/55fca9daa7b34dcbba309d1cef2bca06" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">JDK 1.8 HashMap 的 hash 方法源码:</strong></span></span></p></div><div id="https://www.notion.so/8cfef1e78b574e3d97197f5a51c5ffac" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</span></span></p></div><pre id="https://www.notion.so/89b3f683d4c7412ebd30b05cd6815180" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">int</span> h<span class="token punctuation">;</span>
      <span class="token comment">// key.hashCode()：返回散列值也就是hashcode</span>
      <span class="token comment">// ^ ：按位异或</span>
      <span class="token comment">// >>>:无符号右移，忽略符号位，空位都以0补齐</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</span></span></span></code></pre><div id="https://www.notion.so/94a6622e4fd44930979e8f5573b3871f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</span></span></p></div><pre id="https://www.notion.so/8cb70b1ff830424595be5f0e5aff85a0" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// This function ensures that hashCodes that differ only by</span>
    <span class="token comment">// constant multiples at each bit position have a bounded</span>
    <span class="token comment">// number of collisions (approximately 8 at default load factor).</span>

    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</span></span></span></code></pre><div id="https://www.notion.so/bf924908ba944095a619d2d6fef9be10" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</span></span></p></div><div id="https://www.notion.so/71189e01263048749a217dd8dce6bd93" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所谓 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">“拉链法”</strong></span><span class="SemanticString"> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</span></span></p></div><div id="https://www.notion.so/ed37a203a82a409786cb32f0989fe426" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F06fad652-4518-42d1-a329-704c20a25400%2FUntitled.png?width=421&amp;table=block&amp;id=ed37a203-a82a-4097-86cb-32f0989fe426"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F06fad652-4518-42d1-a329-704c20a25400%2FUntitled.png?width=421&amp;table=block&amp;id=ed37a203-a82a-4097-86cb-32f0989fe426" style="width:421px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/b848c0059c764288a7571db3d5169cde" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/b848c0059c764288a7571db3d5169cde"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">JDK1.8 之后</span></span></h3><div id="https://www.notion.so/be4895f2f79f42c9be5dce9481912b7c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">减少搜索时间</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/3c1611f258b7403b8668bcbdff23367e" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7245b693-ce43-48b8-babf-0e3dfb3b6808%2FUntitled.png?width=453&amp;table=block&amp;id=3c1611f2-58b7-403b-8668-bcbdff23367e"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7245b693-ce43-48b8-babf-0e3dfb3b6808%2FUntitled.png?width=453&amp;table=block&amp;id=3c1611f2-58b7-403b-8668-bcbdff23367e" style="width:453px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><blockquote id="https://www.notion.so/b63e14a1950d4c57b401d139a3625546" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</span></span></blockquote><h3 id="https://www.notion.so/e7ed08591b964c9e9dee7dacc0634089" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e7ed08591b964c9e9dee7dacc0634089"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">HashMap 的长度为什么是 2 的幂次方</span></span></h3><div id="https://www.notion.so/379045af16ba47309039d974d7159069" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(n - 1) &amp; hash</code></span><span class="SemanticString">”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</span></span></p></div><div id="https://www.notion.so/b160e118b61748419d1973f978588429" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作。采用二进制位操作 &amp;，相对于%能够提高运算效率</strong></span><span class="SemanticString">，这就解释了 HashMap 的长度为什么是 2 的幂次方。</span></span></p></div><h3 id="https://www.notion.so/8711cf9710284c939653f36023d13844" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/8711cf9710284c939653f36023d13844"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">HashMap 多线程操作导致死循环问题</span></span></h3><div id="https://www.notion.so/2076f44fc3e24f718859d604ab0f7454" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">主要原因在于并发下的 Rehash 会造成元素之间会形成一个</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">循环链表</strong></span><span class="SemanticString">。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">数据丢失</strong></span><span class="SemanticString">。并发环境下推荐使用 ConcurrentHashMap 。</span></span></p></div><h3 id="https://www.notion.so/e91dfc46e998426dbcd4cf513404d478" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e91dfc46e998426dbcd4cf513404d478"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ConcurrentHashMap 和 Hashtable 的区别</span></span></h3><div id="https://www.notion.so/168ae8deb0fb4abda4709b7e4fa11935" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ConcurrentHashMap</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Hashtable</code></span><span class="SemanticString"> 的区别主要体现在实现线程安全的方式上不同。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/f715e19a2d3a4cb08a0fe7d91a71daad" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">底层数据结构：</strong></span><span class="SemanticString"> JDK1.7 的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ConcurrentHashMap</code></span><span class="SemanticString"> 底层采用 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">分段的数组+链表</strong></span><span class="SemanticString"> 实现，JDK1.8 采用的数据结构跟 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap1.8</code></span><span class="SemanticString"> 的结构一样，数组+链表/红黑二叉树。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Hashtable</code></span><span class="SemanticString"> 和 JDK1.8 之前的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 的底层数据结构类似都是采用 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">数组+链表</strong></span><span class="SemanticString"> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</span></span></li><li id="https://www.notion.so/8595a0ab219746f3b3a6931391dab237" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">实现线程安全的方式（重要）：</strong></span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/7f54f08e522d485c97e753ba038df691" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">在 JDK1.7 的时候，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ConcurrentHashMap</code></span><span class="SemanticString"> 对整个桶数组进行了分割分段(</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString">，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</span></span></li><li id="https://www.notion.so/fde63399e7874a879b18131c5f8434a0" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">到了 JDK1.8 的时候，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ConcurrentHashMap</code></span><span class="SemanticString"> 已经摒弃了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 的概念，而是直接用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Node</code></span><span class="SemanticString"> 数组+链表+红黑树的数据结构来实现，并发控制使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 和 CAS 来操作。（JDK1.6 以后 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString">，虽然在 JDK1.8 中还能看到 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</span></span></li><li id="https://www.notion.so/4f130e71abf44094a0a1a4be616c1565" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Hashtable</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">(同一把锁)</strong></span><span class="SemanticString"> :使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</span></span></li></ul></li></ul><div id="https://www.notion.so/75ab4f180f824f43a0cd8a63f8730d16" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下面，我们再来看看两者底层数据结构的对比图。</span></span></p></div><div id="https://www.notion.so/d13eee9b78f04e37a9ef9410e4a19240" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Hashtable</strong></span><span class="SemanticString"> :</span></span></p></div><div id="https://www.notion.so/c757c44c7fac4e1e93d62121ad7e4def" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F36821e20-352d-4f80-bc5d-6672a8c9dffa%2FUntitled.png?width=421&amp;table=block&amp;id=c757c44c-7fac-4e1e-93d6-2121ad7e4def"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F36821e20-352d-4f80-bc5d-6672a8c9dffa%2FUntitled.png?width=421&amp;table=block&amp;id=c757c44c-7fac-4e1e-93d6-2121ad7e4def" style="width:421px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/9f12f62663f4402d9d1d615041222006" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">JDK1.7 的 ConcurrentHashMap：</strong></span></span></p></div><div id="https://www.notion.so/1b5f9ccb72334c17a40cc3ae633be7e2" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4f417005-ee95-4344-bb50-633b124aed65%2FUntitled.png?width=736&amp;table=block&amp;id=1b5f9ccb-7233-4c17-a40c-c3ae633be7e2"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4f417005-ee95-4344-bb50-633b124aed65%2FUntitled.png?width=736&amp;table=block&amp;id=1b5f9ccb-7233-4c17-a40c-c3ae633be7e2" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/9b0cd6a04bef495b9eccb7d34fcb925f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ConcurrentHashMap</code></span><span class="SemanticString"> 是由 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 数组结构和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashEntry</code></span><span class="SemanticString"> 数组结构组成。</span></span></p></div><div id="https://www.notion.so/45352172a3604838bb17d512e87c09bc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 数组中的每个元素包含一个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashEntry</code></span><span class="SemanticString"> 数组，每个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashEntry</code></span><span class="SemanticString"> 数组属于链表结构。</span></span></p></div><div id="https://www.notion.so/a20e424d130c45b282094bab23454cba" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">JDK1.8 的 ConcurrentHashMap</strong></span><span class="SemanticString"> ：</span></span></p></div><div id="https://www.notion.so/18be64e70c5241f3ac30990ea9e28494" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F910c543c-241b-48c0-8ee5-e322ce6442a1%2FUntitled.png?width=663&amp;table=block&amp;id=18be64e7-0c52-41f3-ac30-990ea9e28494"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F910c543c-241b-48c0-8ee5-e322ce6442a1%2FUntitled.png?width=663&amp;table=block&amp;id=18be64e7-0c52-41f3-ac30-990ea9e28494" style="width:663px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/8377370c1d4745e4a31c2d996dfbb4e1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">JDK1.8 的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ConcurrentHashMap</code></span><span class="SemanticString"> 不再是 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Segment 数组 + HashEntry 数组 + 链表</strong></span><span class="SemanticString">，而是 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Node 数组 + 链表 / 红黑树</strong></span><span class="SemanticString">。不过，Node 只能用于链表的情况，红黑树的情况需要使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">TreeNode</strong></code></span><span class="SemanticString">。当冲突链表达到一定长度时，链表会转换成红黑树。</span></span></p></div><div id="https://www.notion.so/50b208a202b54852a1d5a7d87aab99f0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TreeNode</code></span><span class="SemanticString">是存储红黑树节点，被</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TreeBin</code></span><span class="SemanticString">包装。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TreeBin</code></span><span class="SemanticString">通过</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">root</code></span><span class="SemanticString">属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ConcurrentHashMap</code></span><span class="SemanticString"> 中</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TreeBin</code></span><span class="SemanticString">通过</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">waiter</code></span><span class="SemanticString">属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</span></span></p></div><h3 id="https://www.notion.so/c018d3b925ff4bd2a0d3c49ae252864f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/c018d3b925ff4bd2a0d3c49ae252864f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</strong></span></span></h3><h3 id="https://www.notion.so/034e30b560a24c0d8f4c2b2c02038dca" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/034e30b560a24c0d8f4c2b2c02038dca"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">JDK1.8 之前</strong></span></span></h3><div id="https://www.notion.so/6b809f7d52a343ce9e1c2175c074b342" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd4fb0a2e-7f56-427f-96c8-dff8c2fae62e%2FUntitled.png?width=736&amp;table=block&amp;id=6b809f7d-52a3-43ce-9e1c-2175c074b342"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd4fb0a2e-7f56-427f-96c8-dff8c2fae62e%2FUntitled.png?width=736&amp;table=block&amp;id=6b809f7d-52a3-43ce-9e1c-2175c074b342" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/08a06a458067437b9af9d57d1335c30e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">首先将数据分为一段一段（这个“段”就是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString">）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</span></span></p></div><div id="https://www.notion.so/670c77271e61484ea847b7b1e7452831" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ConcurrentHashMap</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 是由 </strong></span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Segment</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 数组结构和 </strong></span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">HashEntry</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 数组结构组成</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/318cdc40a55b478589a05c428449b0a6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 继承了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString">,所以 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 是一种可重入锁，扮演锁的角色。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashEntry</code></span><span class="SemanticString"> 用于存储键值对数据。</span></span></p></div><pre id="https://www.notion.so/51d7af9471a9498c9d48ed847524de61" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/cf34bd11f3934ed297b557f595e3239b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ConcurrentHashMap</code></span><span class="SemanticString"> 里包含一个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 数组，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 的个数一旦</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">初始化就不能改变</strong></span><span class="SemanticString">。 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</span></span></p></div><div id="https://www.notion.so/2ac76bd61a3d4ca18d39fc158bf921e5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 的结构和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 类似，是一种数组和链表结构，一个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 包含一个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashEntry</code></span><span class="SemanticString"> 数组，每个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashEntry</code></span><span class="SemanticString"> 是一个链表结构的元素，每个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 守护着一个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashEntry</code></span><span class="SemanticString"> 数组里的元素，当对 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashEntry</code></span><span class="SemanticString"> 数组的数据进行修改时，必须首先获得对应的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 的锁。也就是说，对同一 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 的并发写入会被阻塞，不同 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 的写入是可以并发执行的。</span></span></p></div><h3 id="https://www.notion.so/e994ab420df54739bcf37cf7fa8ae1c3" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e994ab420df54739bcf37cf7fa8ae1c3"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">JDK1.8 之后</strong></span></span></h3><div id="https://www.notion.so/761430ca036b4fc1a8f79284b3f09e45" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F39b99f99-9cde-4f5c-8c52-754fbfc972ef%2FUntitled.png?width=663&amp;table=block&amp;id=761430ca-036b-4fc1-a8f7-9284b3f09e45"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F39b99f99-9cde-4f5c-8c52-754fbfc972ef%2FUntitled.png?width=663&amp;table=block&amp;id=761430ca-036b-4fc1-a8f7-9284b3f09e45" style="width:663px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/e000d40eb06143599b6db96621445460" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ConcurrentHashMap</code></span><span class="SemanticString"> 取消了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 分段锁，采用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Node + CAS + synchronized</code></span><span class="SemanticString"> 来保证并发安全。数据结构跟 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString"> 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</span></span></p></div><div id="https://www.notion.so/726533d8a8ba469da78358e488105fbd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Java 8 中，锁粒度更细，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</span></span></p></div><h3 id="https://www.notion.so/786c77bbaace4419930e9be8a76a44d5" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/786c77bbaace4419930e9be8a76a44d5"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/8f5ab618d625459e8913c1b664bb2d6e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">线程安全实现方式</strong></span><span class="SemanticString"> ：JDK 1.7 采用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 分段锁来保证安全， </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 是继承自 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString">。JDK1.8 放弃了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Segment</code></span><span class="SemanticString"> 分段锁的设计，采用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Node + CAS + synchronized</code></span><span class="SemanticString"> 保证线程安全，锁粒度更细，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 只锁定当前链表或红黑二叉树的首节点。</span></span></li><li id="https://www.notion.so/fb7b44a7cd344ff5a896cfbfb114e711" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Hash 碰撞解决方法</strong></span><span class="SemanticString"> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</span></span></li><li id="https://www.notion.so/19113cc201dc47f49109a5b918787a1f" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">并发度</strong></span><span class="SemanticString"> ：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</span></span></li></ul><div id="https://www.notion.so/cb22d7486b0a4cf988fab8bd969f1011" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></article>
    <script src="https://utteranc.es/client.js"
        repo="youthtoday/youthtoday.github.io"
        issue-term="pathname"
        label="✨"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>
  <footer class="Footer">
  <div>&copy; Nick的博客 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>
