<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>Java并发1&nbsp;|&nbsp;Nick的博客</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="Java并发1">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="-fe1f32.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📚&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>分类</span>
        </div>
      </a>
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>关于我</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">Java并发1</h1>
    
      <div class="DateTagBar">
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--pink">
            <a href="tag/Java基础.html">Java基础</a>
          </span>
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--green">
            <a href="tag/并发编程.html">并发编程</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/f15142764c3b4e0c8ca7992fb58abc4d" class="PageRoot"><h1 id="https://www.notion.so/9cb109989f584afbbc3cba7e989dc2d8" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/9cb109989f584afbbc3cba7e989dc2d8"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">什么是进程和线程</span></span></h1><h2 id="https://www.notion.so/2ed5821b86ae419f9d68deaf624eff7e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/2ed5821b86ae419f9d68deaf624eff7e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">进程</span></span></h2><div id="https://www.notion.so/46de39be5f1c473991b2d111e3d37fa6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</span></span></p></div><h2 id="https://www.notion.so/a56121252d8d4470b41b452c03073225" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/a56121252d8d4470b41b452c03073225"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">线程</span></span></h2><div id="https://www.notion.so/69e4ddd57a3d47289dd8c6ec3c040f3f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">线程是比进程更小的执行单位。一个进程在执行过程中可以产生多个线程。同类的线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈、本地方法栈。所以系统在产生一个线程，或者在线程之间切换工作时，负担要比进程小得多。因此，线程也被称为“轻量级进程”。</span></span></p></div><h2 id="https://www.notion.so/bdf32e3f8009490483635adf605e61a8" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/bdf32e3f8009490483635adf605e61a8"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">程序计数器为什么是私有的</span></span></h2><div id="https://www.notion.so/6b1dd01d501949e9a19fa46a8d6f2ce2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">程序计数器有两个作用：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/ea52ccfd2bbd439fa1a7d7764bb99d0e" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</span></span></li><li id="https://www.notion.so/280d6683310a43f28baacf32c66b2340" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程切换回来的时候能够知道该线程上次运行到哪了。</span></span></li></ol><div id="https://www.notion.so/c965a45d5b544855ae4dd1e46b6e2f4e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所以，程序计数器私有主要是为了</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">线程切换后能恢复到正确的执行位置</strong></span><span class="SemanticString">。</span></span></p></div><h2 id="https://www.notion.so/cd4ad14f51344249b07a6a419aa6d5ce" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/cd4ad14f51344249b07a6a419aa6d5ce"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">虚拟机栈和本地方法栈为什么是私有的</span></span></h2><ul class="BulletedListWrapper"><li id="https://www.notion.so/eee08839240a426f8060516c1d38c36a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">每个线程运行时需要的内存称为虚拟机栈，每执行一个方法，就创建一个对应的虚拟机栈帧，栈帧中存放局部变量表、操作数栈、常量池引用等信息。</span></span></li><li id="https://www.notion.so/6eefc349497d44b7a8154c76c19106a8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">本地方法栈和虚拟机栈很类似，区别在于本地方法栈为虚拟机使用到的native方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</span></span></li></ul><div id="https://www.notion.so/1c5b2e42aeb94267bd12fdce96883237" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为了</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">保证线程中的局部变量不被别的线程访问到</strong></span><span class="SemanticString">，虚拟机栈和本地方法栈是线程私有的。</span></span></p></div><h2 id="https://www.notion.so/9b4d28f43894445db7a1f1bd944cf26f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/9b4d28f43894445db7a1f1bd944cf26f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">堆和方法区</span></span></h2><div id="https://www.notion.so/7c83fcdcf9a74374bb99acdfb89b0f49" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">堆和方法区都是所有线程共享的内存空间。堆事进程中最大的一块内存，用于存放新的对象，方法区用于存放已被加载的类的信息、常量、静态变量、即时编译器编译后的代码等数据。方法区是一个概念，堆中的永久代或者元空间是方法区的具体实现。</span></span></p></div><h2 id="https://www.notion.so/b4c6b7d7810b4479a8e63b8f1bd3b3e0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/b4c6b7d7810b4479a8e63b8f1bd3b3e0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">并发与并行</span></span></h2><ul class="BulletedListWrapper"><li id="https://www.notion.so/c06ce20d2028418688f3aeb51d96c3ed" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">并发</strong></span><span class="SemanticString">：两个及两个以上的作业在同一 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">时间段</strong></span><span class="SemanticString"> 内执行。</span></span></li><li id="https://www.notion.so/1dabf5b3691043ca886f310728880756" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">并行</strong></span><span class="SemanticString">：两个及两个以上的作业在同一 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">时刻</strong></span><span class="SemanticString"> 执行。</span></span></li></ul><h2 id="https://www.notion.so/12a593e4b8de48a4824152534c369433" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/12a593e4b8de48a4824152534c369433"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">同步和异步</span></span></h2><ul class="BulletedListWrapper"><li id="https://www.notion.so/7300a2b8ec0c4ecfbb2217fc69b8fb6b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">同步</strong></span><span class="SemanticString"> ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</span></span></li><li id="https://www.notion.so/4c93f3cb938b465eb4b2b8645e38c97a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">异步</strong></span><span class="SemanticString"> ：调用在发出之后，不用等待返回结果，该调用直接返回。</span></span></li></ul><h2 id="https://www.notion.so/30a892b0076c41bb9c372b385f46390d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/30a892b0076c41bb9c372b385f46390d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">为什么使用多线程</span></span></h2><div id="https://www.notion.so/746f53e778a4442da8224533e35e83b3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">先从总体上来说：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/48af3aaf8fb445119c2ac8bac5748df7" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">从计算机底层来说：</strong></span><span class="SemanticString"> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</span></span></li><li id="https://www.notion.so/3675c3960d824fca8e24f570c94dc611" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">从当代互联网发展趋势来说：</strong></span><span class="SemanticString"> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</span></span></li></ul><div id="https://www.notion.so/e5c507f1d82c4f4fb0d90f7e190378b6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">再深入到计算机底层来探讨：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/81d9aa30c1544f3b8a256868edc0e952" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">单核时代</strong></span><span class="SemanticString">： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</span></span></li><li id="https://www.notion.so/590b18ceaaf74cd8a589e42e19a4b544" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">多核时代</strong></span><span class="SemanticString">: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</span></span></li></ul><h2 id="https://www.notion.so/f26ed4bbf7f14d8a9d84bd1727448f79" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/f26ed4bbf7f14d8a9d84bd1727448f79"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">多线程可能的问题</span></span></h2><div id="https://www.notion.so/4e4c39d2f9a340a5bb9f9803cc4a445c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">内存泄漏、死锁、线程不安全等等</span></span></p></div><h2 id="https://www.notion.so/ff91484fe7284ab7973d9edf2775ffb7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/ff91484fe7284ab7973d9edf2775ffb7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">线程的生命周期和状态</span></span></h2><div id="https://www.notion.so/94975d0eea4d44e881b46699cef64659" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/413dbb9c0c1b4874b99fba86472796bf" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">New：初始状态，线程被创建出来但没有被调用start()</span></span></li><li id="https://www.notion.so/93a54aaea4504c539904fa42c5146917" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Runnable：运行状态，线程被调用了start()等待运行的状态</span></span></li><li id="https://www.notion.so/00c927433c884bfbbbc928e8c4a0cd0a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Blocked：阻塞状态，需要等待锁释放</span></span></li><li id="https://www.notion.so/1e5227dec1764c7bbf898893eafa6063" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Waiting：等待状态，该线程需要等待其他线程做出一些特定动作（通知或中断）</span></span></li><li id="https://www.notion.so/1ac6ca315ed445f6b28fce5ddf953c57" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Timed_Waiting：超时等待状态，可以在指定时间后自行返回而不是像Waiting一样一直等待</span></span></li><li id="https://www.notion.so/2d76549f867e48348aebaae1cb33f028" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Terminated：终止状态，表示该线程已经运行完毕</span></span></li></ul><div id="https://www.notion.so/dbdb187eb58b4cf48743a3d1e3bdecbe" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb983c515-21f5-4d6f-8ff0-c78dba948610%2FUntitled.png?width=913&amp;table=block&amp;id=dbdb187e-b58b-4cf4-8743-a3d1e3bdecbe"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb983c515-21f5-4d6f-8ff0-c78dba948610%2FUntitled.png?width=913&amp;table=block&amp;id=dbdb187e-b58b-4cf4-8743-a3d1e3bdecbe" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/78bd3ec5c700437ba881fdb1e383f6ce" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">线程创建之后它将处于 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">NEW（新建）</strong></span><span class="SemanticString"> 状态，调用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">start()</code></span><span class="SemanticString"> 方法后开始运行，线程这时候处于 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">READY（可运行）</strong></span><span class="SemanticString"> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">RUNNING（运行）</strong></span><span class="SemanticString"> 状态。</span></span></p></div><blockquote id="https://www.notion.so/ee1e120a17184fc7a5942866eb6e2d1c" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。</span></span><div id="https://www.notion.so/ebb40654028045de870a49b95a7abfc5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">为什么 JVM 没有区分这两种状态呢？</strong></span><span class="SemanticString"> </span></span></p></div><div id="https://www.notion.so/9d7e771010b24ae78dea3692d8f746be" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</span></span></p></div></blockquote><div id="https://www.notion.so/6653283a64ad4c8f91095687f08c3efc" class="Image Image--PageWidth"><figure><a href="#"><img src="#" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/d861978820a343a0a3f791d571027689" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">当线程执行 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">wait()</code></span><span class="SemanticString">方法之后，线程进入 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">WAITING（等待）</strong></span><span class="SemanticString"> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</span></span></li><li id="https://www.notion.so/a6bd662cdec14528a0d030c4b65d8e87" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">TIMED_WAITING(超时等待)</strong></span><span class="SemanticString"> 状态相当于在等待状态的基础上增加了超时限制，比如通过 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sleep（long millis）</code></span><span class="SemanticString">方法或 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">wait（long millis）</code></span><span class="SemanticString">方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</span></span></li><li id="https://www.notion.so/6bec56936d9c4389b4056cb0a885c3b9" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">当线程进入 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 方法/块或者调用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">wait</code></span><span class="SemanticString"> 后（被 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">notify</code></span><span class="SemanticString">）重新进入 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 方法/块，但是锁被其它线程占有，这个时候线程就会进入 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">BLOCKED（阻塞）</strong></span><span class="SemanticString"> 状态。</span></span></li><li id="https://www.notion.so/afc95f72055e4b71835a821ea09c95b5" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">线程在执行完了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">run()</code></span><span class="SemanticString">方法之后将会进入到 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">TERMINATED（终止）</strong></span><span class="SemanticString"> 状态。</span></span></li></ul><h2 id="https://www.notion.so/6e714207a9d74e94800fd1415760ce49" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/6e714207a9d74e94800fd1415760ce49"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">什么是上下文切换?</strong></strong></span></span></h2><div id="https://www.notion.so/b573f59e6824419291daf1fbd4ebc563" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">线程在执行过程中会有自己的运行条件和状态（也称上下文），比如程序计数器、栈信息等。当出现如下情况，线程会从占用CPU状态中退出：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/76080f9d58f843cfb500b809c50e5f94" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">主动让出CPU，比如调用wait()、sleep()方法</span></span></li><li id="https://www.notion.so/3b5e5b04cf004c168e4aa1018de1650a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死</span></span></li><li id="https://www.notion.so/a8da536fd42f4f0e945bef6ead009304" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">调用了阻塞类型的系统中断，比如请求IO，线程被阻塞</span></span></li><li id="https://www.notion.so/346f7ad0c84a4ed8bbff08381a87bb1d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">被终止或结束运行</span></span></li></ul><div id="https://www.notion.so/7b79de2ec6a0452cbf0ee89f2371a2e5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">前三种都会发生线程切换，线程切换意味着要保存当前线程的上下文，留待线程下次占用CPU的时候恢复现场，并加载下一个将要占用CPU的线程上下文。这就是所谓的 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">上下文切换</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/ab90341eef1f46dd88628eb717d8145c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</span></span></p></div><h2 id="https://www.notion.so/405e1da51bdd44fe9c49d6dd0caf6dd3" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/405e1da51bdd44fe9c49d6dd0caf6dd3"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">什么是线程死锁？</span></span></h2><div id="https://www.notion.so/a01dd3a2b2d1484e89457639457c695b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</span></span></p></div><div id="https://www.notion.so/5944b590c6bd40bbaa2eaf84fe2ab95f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">产生死锁的四个必要条件：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/1507d07f9ffd4a2fa5a56ddf685e0c39" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">互斥条件</strong></span><span class="SemanticString">：该资源任意一个时刻只由一个线程占用。</span></span></li><li id="https://www.notion.so/5c7adefdd4b5492a99baf3868aa0a9ee" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">请求与保持条件</strong></span><span class="SemanticString">：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</span></span></li><li id="https://www.notion.so/88699c02edb74210b61698d17f8d0cd5" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不剥夺条件</strong></span><span class="SemanticString">：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</span></span></li><li id="https://www.notion.so/08315bdd7c0e495eb0f4a078e2e2d429" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">循环等待条件</strong></span><span class="SemanticString">：若干线程之间形成一种头尾相接的循环等待资源关系</span></span></li></ol><h2 id="https://www.notion.so/c924f69ab4e94f249af2b19a16d6c4f7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/c924f69ab4e94f249af2b19a16d6c4f7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">如何预防和避免死锁？</span></span></h2><div id="https://www.notion.so/3623b13274f44c14be201139d8dd960f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">预防死锁</span></span></p></div><div id="https://www.notion.so/4a41f2bd6176484bbd751571ea66db4a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">破坏死锁的产生的必要条件即可：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/95c2514015e843d1b5a0889b60776863" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">破坏请求与保持条件</strong></span><span class="SemanticString"> ：一次性申请所有的资源。</span></span></li><li id="https://www.notion.so/014f7ba86ad84e22a3f3918192325a76" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">破坏不剥夺条件</strong></span><span class="SemanticString"> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</span></span></li><li id="https://www.notion.so/fd2117d3145846ea806d9be545a1e72c" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">破坏循环等待条件</strong></span><span class="SemanticString"> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</span></span></li></ol><div id="https://www.notion.so/e4d608108e8e4288b1778ed2134b8eed" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">避免死锁</span></span></p></div><div id="https://www.notion.so/1236580141a24a11a9e004fdacd186ad" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</span></span></p></div><blockquote id="https://www.notion.so/7669cdcbbf4f4e57a9e154abcfc0beb4" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">安全状态 指的是系统能够按照某种线程推进顺序（P1、P2、P3.....Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 &lt;P1、P2、P3.....Pn&gt; 序列为安全序列。</span></span></blockquote><h2 id="https://www.notion.so/0ab52809995d4b36b0feaed5122f1041" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/0ab52809995d4b36b0feaed5122f1041"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">sleep()方法和wait()方法对比</span></span></h2><div id="https://www.notion.so/36c5a7e939f1438ca7829ad293af865b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">共同点</strong></span><span class="SemanticString"> ：两者都可以暂停线程的执行。</span></span></p></div><div id="https://www.notion.so/6ee70d056b51449b80fe8bb8245c4a3a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">区别</strong></span><span class="SemanticString"> ：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/733a616103974625917d020ac6514cd0" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">sleep()</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 方法没有释放锁，而 </strong></span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">wait()</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 方法释放了锁</strong></span><span class="SemanticString"> 。</span></span></li><li id="https://www.notion.so/7d6d56658238413cbf4d6c42f81aca01" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">wait()</code></span><span class="SemanticString"> 通常被用于线程间交互/通信，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sleep()</code></span><span class="SemanticString">通常被用于暂停执行。</span></span></li><li id="https://www.notion.so/7c296a0759d54cefadfa03a8e9e6a9a4" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">wait()</code></span><span class="SemanticString"> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">notify()</code></span><span class="SemanticString">或者 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">notifyAll()</code></span><span class="SemanticString"> 方法。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sleep()</code></span><span class="SemanticString">方法执行完成后，线程会自动苏醒，或者也可以使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">wait(long timeout)</code></span><span class="SemanticString"> 超时后线程会自动苏醒。</span></span></li><li id="https://www.notion.so/02fe02e977b54fde804838f309aa5f24" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sleep()</code></span><span class="SemanticString"> 是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Thread</code></span><span class="SemanticString"> 类的静态本地方法，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">wait()</code></span><span class="SemanticString"> 则是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Object</code></span><span class="SemanticString"> 类的本地方法。</span></span></li></ul><h2 id="https://www.notion.so/32bfd630bfe0424f9002f88488b33779" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/32bfd630bfe0424f9002f88488b33779"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">为什么wait()方法不定义在Thread中？</span></span></h2><div id="https://www.notion.so/900a261a9b76489a828e2e829dce705e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">wait()是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象都拥有对象锁，既然是要释放对象锁，自然是对对象进行操作而非线程。</span></span></p></div><div id="https://www.notion.so/aa40d29443c544e0b6f0075d9c2d475a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">反之，sleep()方法是让当前线程暂停执行，不涉及到对象锁，也不需要获得对象锁。</span></span></p></div><h2 id="https://www.notion.so/354d678775ed43bbadc4adcd125d2e20" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/354d678775ed43bbadc4adcd125d2e20"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">可以直接调用Thread类的run方法吗？</span></span></h2><div id="https://www.notion.so/c4d4fc9e9dde43a18a566c57ac5696c4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">new一个Thread，线程就进入了新建状态。调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程。但是，直接执行 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">run()</code></span><span class="SemanticString">
 方法，会把 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">run()</code></span><span class="SemanticString"> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。
总结：</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">调用 </strong></span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">start()</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 方法方可启动线程并使线程进入就绪状态，直接执行 </strong></span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">run()</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 方法的话不会以多线程的方式执行。</strong></span></span></p></div></article>
    <script src="https://utteranc.es/client.js"
        repo="youthtoday/youthtoday.github.io"
        issue-term="pathname"
        label="✨"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>
  <footer class="Footer">
  <div>&copy; Nick的博客 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>
