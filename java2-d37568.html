<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>Java并发2&nbsp;|&nbsp;Nick的博客</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="Java并发2">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="-fe1f32.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📚&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>分类</span>
        </div>
      </a>
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>关于我</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">Java并发2</h1>
    
      <div class="DateTagBar">
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--pink">
            <a href="tag/Java基础.html">Java基础</a>
          </span>
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--green">
            <a href="tag/并发编程.html">并发编程</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/d37568ac5f95425094bd505449e54819" class="PageRoot"><h1 id="https://www.notion.so/d50bcd58051f40bba29e9c351f9a600f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/d50bcd58051f40bba29e9c351f9a600f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">volatile关键字</span></span></h1><h3 id="https://www.notion.so/844be4ab681f423eb9b97748d9949084" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/844be4ab681f423eb9b97748d9949084"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">如何保证变量的可见性？</span></span></h3><div id="https://www.notion.so/638ab0868def41eeb7e8646a449e0c50" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 Java 中，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString"> 关键字可以保证变量的可见性，如果我们将变量声明为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">volatile</strong></code></span><span class="SemanticString"> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</span></span></p></div><div id="https://www.notion.so/5ad1bd301a024b74a2f3a357ef3aa64c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString">关键字能保证数据的可见性，但不能保证数据的原子性。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString">关键字两者都能保证。</span></span></p></div><h3 id="https://www.notion.so/9ba1029b440645a8894c7a70032bf38d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/9ba1029b440645a8894c7a70032bf38d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">如何禁止指令重排序？</span></span></h3><div id="https://www.notion.so/c11bdfdb11a74c6d81e28b68e352141b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">volatile</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 关键字还有一个重要的作用就是防止 JVM 的指令重排序。</strong></span><span class="SemanticString"> 如果我们将变量声明为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">volatile</strong></code></span><span class="SemanticString"> ，在对这个变量进行读写操作的时候，会通过插入特定的 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">内存屏障</strong></span><span class="SemanticString"> 的方式来禁止指令重排序。</span></span></p></div><div id="https://www.notion.so/22f3ff3a63804bf49602022f8170fae0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 Java 中，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Unsafe</code></span><span class="SemanticString"> 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：</span></span></p></div><pre id="https://www.notion.so/cb5f422a5d4446a59216df82c3dcb04b" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">loadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">storeFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">fullFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></span></code></pre><div id="https://www.notion.so/ba6f2a7046a84a93a6bd7eb32b4476a0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">理论上来说，你通过这个三个方法也可以实现和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString">禁止重排序一样的效果，只是会麻烦一些。</span></span></p></div><div id="https://www.notion.so/8c5f5891d6464b03b482114bfca72017" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">下面我以一个常见的面试题为例讲解一下 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString"> 关键字禁止指令重排序的效果。</span></span></p></div><div id="https://www.notion.so/0e05536c5c984182a32e075aadfa4e2e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</span></span></p></div><div id="https://www.notion.so/a1585016fea743379e8c788370a8c3a0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">双重校验锁实现对象单例（线程安全）</strong></span><span class="SemanticString"> ：</span></span></p></div><pre id="https://www.notion.so/db7f34131ce64aefa88d7c9e0c9c5452" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//类对象加锁</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/bc403ab68b464e6fbf82c172c223bdf9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uniqueInstance</code></span><span class="SemanticString"> 采用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString"> 关键字修饰也是很有必要的， </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uniqueInstance = new Singleton();</code></span><span class="SemanticString"> 这段代码其实是分为三步执行：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/f5ceba5293984d00b368cec618963d69" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uniqueInstance</code></span><span class="SemanticString"> 分配内存空间</span></span></li><li id="https://www.notion.so/7e991476a6b44dd38002b5e02dc585cb" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">初始化 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uniqueInstance</code></span></span></li><li id="https://www.notion.so/b28fbb41e4d842b79d7e05e9476f9129" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">将 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uniqueInstance</code></span><span class="SemanticString"> 指向分配的内存地址</span></span></li></ol><div id="https://www.notion.so/9819c20d1d7e43b0a9b02b76c33fbd09" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">getUniqueInstance</code></span><span class="SemanticString">() 后发现 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uniqueInstance</code></span><span class="SemanticString"> 不为空，因此返回 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uniqueInstance</code></span><span class="SemanticString">，但此时 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uniqueInstance</code></span><span class="SemanticString"> 还未被初始化。</span></span></p></div><h3 id="https://www.notion.so/e7b9d00fe68445aba555bb9a440e3cab" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e7b9d00fe68445aba555bb9a440e3cab"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">volatile 可以保证原子性么？</span></span></h3><div id="https://www.notion.so/9a7c6da18ecf45009ce24841afba19a1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">volatile</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></span></span></p></div><div id="https://www.notion.so/a42a5f40db5d4a0e9327e5c21e64ee2a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们通过下面的代码即可证明：</span></span></p></div><pre id="https://www.notion.so/16d1f8e862834de19f68e71f0e2cc845" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatoleAtomicityDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token keyword">int</span> inc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        inc<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/b8c230d22604437aa8e233c9f16bb4fe" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">很多人会误认为自增操作 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">inc++</code></span><span class="SemanticString"> 是原子性的，实际上，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">inc++</code></span><span class="SemanticString"> 其实是一个复合操作，包括三步：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/9a648d4228374428a2fe57977ca136b0" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">读取 inc 的值。</span></span></li><li id="https://www.notion.so/9697fdcfa26b43978c9073c3966065d8" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">对 inc 加 1。</span></span></li><li id="https://www.notion.so/2db619584cfe4ac28f7f7f6f28c6957a" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">将 inc 的值写回内存。</span></span></li></ol><div id="https://www.notion.so/e06f3b7221c24440a4bbf0679f2292ac" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString"> 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/9c5d29e45535496696ba5c0f4ef75a6d" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">线程 1 对 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">inc</code></span><span class="SemanticString"> 进行读取操作之后，还未对其进行修改。线程 2 又读取了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">inc</code></span><span class="SemanticString">的值并对其进行修改（+1），再将</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">inc</code></span><span class="SemanticString"> 的值写回内存。</span></span></li><li id="https://www.notion.so/45e6da5300914096807e7e5a272b3588" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">线程 2 操作完毕后，线程 1 对 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">inc</code></span><span class="SemanticString">的值进行修改（+1），再将</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">inc</code></span><span class="SemanticString"> 的值写回内存。</span></span></li></ol><div id="https://www.notion.so/156584c06ced4ecfbf6edc75fee50c17" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这也就导致两个线程分别对 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">inc</code></span><span class="SemanticString"> 进行了一次自增操作后，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">inc</code></span><span class="SemanticString"> 实际上只增加了 1。</span></span></p></div><div id="https://www.notion.so/ba133367f3954e20b277557f21c5e09c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">其实，如果想要保证上面的代码运行正确也非常简单，利用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Lock</code></span><span class="SemanticString">或者</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">AtomicInteger</code></span><span class="SemanticString">都可以。</span></span></p></div><div id="https://www.notion.so/c7181e4b235d4ddc819749b114ab2bfd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 改进：</span></span></p></div><pre id="https://www.notion.so/7cec04e55fc84a1c84b5ae3117e3ffca" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    inc<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/23bc2da69e8348f59ca0de3176ce2d8d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">AtomicInteger</code></span><span class="SemanticString"> 改进：</span></span></p></div><pre id="https://www.notion.so/1b18abb3472d4a63b6b872f89dcbce66" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">public</span> <span class="token class-name">AtomicInteger</span> inc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    inc<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/50b52e717e2e44ca8be2ec015ea8b031" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString"> 改进：</span></span></p></div><pre id="https://www.notion.so/b508df9852ef4d25b426241ee890151f" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span></span></span><span class="SemanticString"><span><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        inc<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></span></span></span></code></pre><h2 id="https://www.notion.so/13f5ecd4018244e7a672e1fd0e2aa9e7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/13f5ecd4018244e7a672e1fd0e2aa9e7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">乐观锁和悲观锁</span></span></h2><h3 id="https://www.notion.so/12de497405c7433da448fc3e22e3535b" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/12de497405c7433da448fc3e22e3535b"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">什么是悲观锁？使用场景是什么？</span></span></h3><div id="https://www.notion.so/262ad4f8bbd84078888a4b71a21ed0a6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。</span></span></p></div><div id="https://www.notion.so/d9dc1d7b8ad4425d95c774012ebad45a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">也就是说，</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/f4552552e64c4ce3ba89eff82d0fb544" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">像 Java 中</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString">和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString">等独占锁就是悲观锁思想的实现。</span></span></p></div><div id="https://www.notion.so/b6e79adddede405fbd8acfce220339ac" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能。</strong></span></span></p></div><h3 id="https://www.notion.so/6208624639ca40378a8004f4f54971a1" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/6208624639ca40378a8004f4f54971a1"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">什么是乐观锁？使用场景是什么？</span></span></h3><div id="https://www.notion.so/69cd593401e64615916f3a20dc828803" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</span></span></p></div><div id="https://www.notion.so/e370a5e3bd3044c0b11df9ed3dc08be7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 Java 中</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">java.util.concurrent.atomic</code></span><span class="SemanticString">包下面的原子变量类就是使用了乐观锁的一种实现方式 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">CAS</strong></span><span class="SemanticString"> 实现的。</span></span></p></div><div id="https://www.notion.so/5bfe9a8cc1b14b5890386ff0e3b8eb49" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">乐观锁通常多于写比较少的情况下（多读场景），避免频繁加锁影响性能，大大提升了系统的吞吐量。</strong></span></span></p></div><h3 id="https://www.notion.so/7bc7425860b044188ed04a4c7c1e17cd" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/7bc7425860b044188ed04a4c7c1e17cd"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">如何实现乐观锁？</span></span></h3><div id="https://www.notion.so/2e955f09c0d843fd90c6876e7e19ab7d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</span></span></p></div><h3 id="https://www.notion.so/5e0d824849714934b073d181b2dc89a0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/5e0d824849714934b073d181b2dc89a0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">版本号机制</span></span></h3><div id="https://www.notion.so/55472fc42a5b45d687dfdafe9a122407" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一般是在数据表中加上一个数据版本号 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">version</code></span><span class="SemanticString"> 字段，表示数据被修改的次数。当数据被修改时，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">version</code></span><span class="SemanticString"> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">version</code></span><span class="SemanticString"> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">version</code></span><span class="SemanticString"> 值相等时才更新，否则重试更新操作，直到更新成功。</span></span></p></div><h3 id="https://www.notion.so/d72d84d1e62b4b938d9ca67204b11bee" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/d72d84d1e62b4b938d9ca67204b11bee"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">CAS</span></span></h3><div id="https://www.notion.so/269ea7aff2e34987a2538b04d3c55ff6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">CAS 的全称是 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Compare And Swap（比较与交换）</strong></span><span class="SemanticString">，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</span></span></p></div><div id="https://www.notion.so/714e9d232c51447e9c95a37ee8770667" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">CAS 涉及到三个操作数：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/97952cfe896c44669f72a05dc05d98d0" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">V</strong></span><span class="SemanticString"> ：要更新的变量值(Var)</span></span></li><li id="https://www.notion.so/b428f29dc8f141219051e3e02a583dac" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">E</strong></span><span class="SemanticString"> ：预期值(Expected)</span></span></li><li id="https://www.notion.so/ed87bf1e76924de99affb88a39a371e8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">N</strong></span><span class="SemanticString"> ：拟写入的新值(New)</span></span></li></ul><div id="https://www.notion.so/442bc269cea74981b2cc27ed260a2d64" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</span></span></p></div><h3 id="https://www.notion.so/7a076bb5221f45f4ae756752f0b84a3b" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/7a076bb5221f45f4ae756752f0b84a3b"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">乐观锁存在的问题</span></span></h3><h3 id="https://www.notion.so/d99ed69f0d634094ab48406d9a986118" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/d99ed69f0d634094ab48406d9a986118"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ABA 问题</span></span></h3><div id="https://www.notion.so/ce647178de9f46ea95b421c9327e20f7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，但是这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">&quot;ABA&quot;问题。</strong></span></span></p></div><div id="https://www.notion.so/7bf8c4dd33d94e50b1b110eff373a8f4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">ABA 问题的解决思路是在变量前面追加上</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">版本号或者时间戳</strong></span><span class="SemanticString">。JDK 1.5 以后的</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">AtomicStampedReference</code></span><span class="SemanticString"> 类就是用来解决 ABA 问题的，其中的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">compareAndSet()</code></span><span class="SemanticString"> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</span></span></p></div><h3 id="https://www.notion.so/63ad94507bd6436ca3dc5af49c057f4c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/63ad94507bd6436ca3dc5af49c057f4c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">循环时间长开销大</strong></span></span></h3><div id="https://www.notion.so/3d843b23a83f4e48b6c88e4d0c045376" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</span></span></p></div><h3 id="https://www.notion.so/7b2a0cbf752d41a8b5ce4f94fc9307d6" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/7b2a0cbf752d41a8b5ce4f94fc9307d6"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">只能保证一个共享变量的原子操作</span></span></h3><div id="https://www.notion.so/5eb233c41500445397e25ba9ccd807a1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">AtomicReference</code></span><span class="SemanticString">类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">锁</strong></span><span class="SemanticString">或者利用</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">AtomicReference</code></span><span class="SemanticString">类把多个共享变量</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">合并成一个共享变量</strong></span><span class="SemanticString">来操作。</span></span></p></div><h1 id="https://www.notion.so/4d88af37a71141b583a9011dd448001d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/4d88af37a71141b583a9011dd448001d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Synchronized关键字</span></span></h1><div id="https://www.notion.so/c9ee619d941f4a1f93d859982323f085" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString">是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</span></span></p></div><h3 id="https://www.notion.so/90dbed7ae48444888e05b6242670c058" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/90dbed7ae48444888e05b6242670c058"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">如何使用 synchronized？</span></span></h3><div id="https://www.notion.so/6879f55f697e4fd9a9e6dc6323e482ba" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 关键字的使用方式主要有下面 3 种：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/14951247df5b4165985b039276795011" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">修饰实例方法</span></span></li><li id="https://www.notion.so/233fb48dfdb34fd3af678fe5331e8bf4" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">修饰静态方法</span></span></li><li id="https://www.notion.so/eee3d86218934b43bab7ea25696efdb2" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">修饰代码块</span></span></li></ol><div id="https://www.notion.so/0e1e8b39d4b0478c89a9592e497dde9a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1、修饰实例方法</strong></span><span class="SemanticString"> （锁当前对象实例）</span></span></p></div><div id="https://www.notion.so/b3eb16215c6a49549404b034ad5be465" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">给当前对象实例加锁，进入同步代码前要获得 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">当前对象实例的锁</strong></span><span class="SemanticString"> 。</span></span></p></div><pre id="https://www.notion.so/25b2abe7f0ed47be8c31b8f00cf9389d" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/e94b6e8cb5bf428a98b6c51480de8705" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2、修饰静态方法</strong></span><span class="SemanticString"> （锁当前类）</span></span></p></div><div id="https://www.notion.so/0349b31bd7074de0a8a7da5f873e0ab9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">给当前clas加锁，会作用于类class所有对象实例 ，进入同步代码前要获得 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">当前 class 的锁</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/da59ab4dcd3c4abbb68a77947e32e781" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</span></span></p></div><pre id="https://www.notion.so/637da11ae6cf4bf8b9cc55fc4de65559" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/e874cc7052cc4be09d9aacf2f6a8ccb1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">静态 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 方法和非静态 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 方法，而线程 B 需要调用这个实例对象所属类的静态 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 方法，是允许的，不会发生互斥现象，因为访问静态 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 方法占用的锁是当前类的锁，而访问非静态 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 方法占用的锁是当前实例对象锁。</span></span></p></div><div id="https://www.notion.so/a6f3857624c6433db2ec6c4a943fd704" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">3、修饰代码块</strong></span><span class="SemanticString"> （锁指定对象/类）</span></span></p></div><div id="https://www.notion.so/62819ff7faba4501b492386537dd4c12" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">对括号里指定的对象/类加锁：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/b410d86e185843719744159ad67c1426" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized(object)</code></span><span class="SemanticString"> 表示进入同步代码库前要获得 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">给定对象的锁</strong></span><span class="SemanticString">。</span></span></li><li id="https://www.notion.so/9e41e7edd0e140fbbbcfca4eea054760" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized(类.class)</code></span><span class="SemanticString"> 表示进入同步代码前要获得 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">给定 Class 的锁</strong></span></span></li></ul><pre id="https://www.notion.so/18eff833a2fb47cab3b495179b282c03" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/d176c0afb11f4cea8177b39b6538884c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">总结：</strong></span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/b387fd20a4c24d968d4e5942b533a033" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 关键字加到 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">static</code></span><span class="SemanticString"> 静态方法和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized(class)</code></span><span class="SemanticString"> 代码块上都是是给 Class 类上锁；</span></span></li><li id="https://www.notion.so/d65956b38a0d4bc684adcc9d00808bb5" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 关键字加到实例方法上是给对象实例上锁；</span></span></li><li id="https://www.notion.so/3d889f80a832464baf6253ae29f309ae" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">尽量不要使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized(String a)</code></span><span class="SemanticString"> 因为 JVM 中，字符串常量池具有缓存功能。</span></span></li></ul><h3 id="https://www.notion.so/6fa168b9af654e0fafe485626ae0daba" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/6fa168b9af654e0fafe485626ae0daba"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">构造方法可以用 synchronized 修饰么？</strong></span></span></h3><div id="https://www.notion.so/e924e59004e24cc6ace829ce1c5057ac" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">先说结论：</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">构造方法不能使用 synchronized 关键字修饰。</strong></span></span></p></div><div id="https://www.notion.so/0914ac31dd964851acf3706553031db0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">构造方法本身就属于线程安全的，不存在同步的构造方法一说。</span></span></p></div><h2 id="https://www.notion.so/81aebf5efb6b4045b25f3aac1d274bfe" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/81aebf5efb6b4045b25f3aac1d274bfe"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">synchronized 底层原理了解吗？</strong></strong></span></span></h2><div id="https://www.notion.so/0292189aacaf4172b0b11dfb84662bc2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">synchronized 关键字底层原理属于 JVM 层面的东西。</span></span></p></div><div id="https://www.notion.so/6cab479592894c7f8d6adb1e54ae741d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">synchronized 同步语句块的情况</strong></strong></span></span></p></div><div id="https://www.notion.so/0d4effb58d024931affa29bd3739d4ca" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 同步语句块的实现使用的是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">monitorenter</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">monitorexit</code></span><span class="SemanticString"> 指令，其中 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">monitorenter</code></span><span class="SemanticString"> 指令指向同步代码块的开始位置，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">monitorexit</code></span><span class="SemanticString"> 指令则指明同步代码块的结束位置。</span></span></p></div><div id="https://www.notion.so/b87fe979238b4fada29fa5926177d3ed" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当执行 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">monitorenter</code></span><span class="SemanticString"> 指令时，线程试图获取锁也就是获取 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">对象监视器 </strong></span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">monitor</strong></code></span><span class="SemanticString"> 的持有权。</span></span></p></div><blockquote id="https://www.notion.so/ac45e98eb7ee47c29795ac69d4d0383f" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由</span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitoropen in new window</a></span><span class="SemanticString">实现的。每个对象中都内置了一个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ObjectMonitor</code></span><span class="SemanticString">对象。
另外，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">wait/notify</code></span><span class="SemanticString">等方法也依赖于</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">monitor</code></span><span class="SemanticString">对象，这就是为什么只有在同步的块或者方法中才能调用</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">wait/notify</code></span><span class="SemanticString">等方法，否则会抛出</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">java.lang.IllegalMonitorStateException</code></span><span class="SemanticString">的异常的原因。</span></span></blockquote><div id="https://www.notion.so/fc7410bd3da645bab622ac29c6d4e808" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在执行</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">monitorenter</code></span><span class="SemanticString">时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。如果获取对象锁失败，那当前线程就要</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">阻塞等待</strong></span><span class="SemanticString">，直到锁被另外一个线程释放为止。</span></span></p></div><div id="https://www.notion.so/5b997cf5ea31406bb786a99e0ab8584c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">对象锁的的拥有者线程才可以执行 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">monitorexit</code></span><span class="SemanticString">指令来释放锁。在执行 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">monitorexit</code></span><span class="SemanticString">指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</span></span></p></div><div id="https://www.notion.so/0a694b9d0a394089a00ba18ab5bc4d03" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa9445e55-a2bf-4c15-b42f-308c8cd7e007%2FUntitled.png?width=1144&amp;table=block&amp;id=0a694b9d-0a39-4089-a00b-a18ab5bc4d03"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa9445e55-a2bf-4c15-b42f-308c8cd7e007%2FUntitled.png?width=1144&amp;table=block&amp;id=0a694b9d-0a39-4089-a00b-a18ab5bc4d03" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/6faeb44df4d04b5ea42af5f1ea5ab402" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">synchronized 修饰方法的的情况</strong></strong></span></span></p></div><div id="https://www.notion.so/e987b4e78a414176bfd517b6578ca160" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 修饰的方法并没有 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">monitorenter</code></span><span class="SemanticString"> 指令和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">monitorexit</code></span><span class="SemanticString"> 指令，取得代之的确实是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ACC_SYNCHRONIZED</code></span><span class="SemanticString"> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ACC_SYNCHRONIZED</code></span><span class="SemanticString"> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</span></span></p></div><div id="https://www.notion.so/78733c225a0147b28f43e8a16b77f86e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</span></span></p></div><h3 id="https://www.notion.so/5de037777c44438ea37076c3e2db6f2d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/5de037777c44438ea37076c3e2db6f2d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">synchronized 和 volatile 有什么区别？</span></span></h3><div id="https://www.notion.so/71e00abf5a704b3d8a288f1d0282e163" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 关键字和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString"> 关键字是两个互补的存在，而不是对立的存在！</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/32024f60c8bf4ce3a7578d4929d469ea" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString"> 关键字是线程同步的轻量级实现，所以 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString">性能肯定比</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString">关键字要好 。但是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString"> 关键字只能用于变量而 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 关键字可以修饰方法以及代码块 。</span></span></li><li id="https://www.notion.so/02ab0140d0ae4f03a76cc439baf105b2" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString"> 关键字能保证数据的可见性，但不能保证数据的原子性。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 关键字两者都能保证。</span></span></li><li id="https://www.notion.so/b2c67ca3938a4b47a8f400796cc1782c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString">关键字主要用于解决变量在多个线程之间的可见性，而 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 关键字解决的是多个线程之间访问资源的同步性。</span></span></li></ul><h1 id="https://www.notion.so/4be5f895077b4ca9a9899768eabc1add" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/4be5f895077b4ca9a9899768eabc1add"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">AQS</span></span></h1><div id="https://www.notion.so/f9ec7f91bedb498eb0eb7c62ca08c7c7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">AQS的全称为AbstractQueuedSynchronizer，抽象队列同步器。这个类在java.util.concurrent.locks包下。AQS就是一个抽象类，主要用来构建锁和同步器。</span></span></p></div><pre id="https://www.notion.so/d4b2d5b85ff84095a509609952bdfc4e" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractOwnableSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span></span></span></span></code></pre><h2 id="https://www.notion.so/8e5e87dc21ed4ccfa61c6d1ed413c67a" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/8e5e87dc21ed4ccfa61c6d1ed413c67a"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">AQS原理</span></span></h2><h3 id="https://www.notion.so/a8a6963f5bf740609145f1b6f098e7ce" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/a8a6963f5bf740609145f1b6f098e7ce"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">AQS核心思想</span></span></h3><div id="https://www.notion.so/6ecf9b2b6cae419885f67be10816309d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制。这个机制AQS是基于CLH锁实现的。</span></span></p></div><div id="https://www.notion.so/5267b996913a4b0892854541cb9e1175" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</span></span></p></div><div id="https://www.notion.so/98d2c24368364384895ec15a5551d398" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">CLH 队列锁结构如下图所示：</span></span></p></div><div id="https://www.notion.so/ade1c9b7dd704467af3d1447d0f619ce" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe785ea21-e0a6-46ea-9fc5-cb3a0026d10c%2FUntitled.png?width=1354&amp;table=block&amp;id=ade1c9b7-dd70-4467-af3d-1447d0f619ce"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe785ea21-e0a6-46ea-9fc5-cb3a0026d10c%2FUntitled.png?width=1354&amp;table=block&amp;id=ade1c9b7-dd70-4467-af3d-1447d0f619ce" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/5d57eaee244b4207a71ef1f2cf90f694" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">AQS(</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">AbstractQueuedSynchronizer</code></span><span class="SemanticString">)的核心原理图如下：</span></span></p></div><div id="https://www.notion.so/24ca2640ceca4deba14afa524fcc347e" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F65e7f30f-69d1-4316-bfa1-75565c769f47%2FUntitled.png?width=852&amp;table=block&amp;id=24ca2640-ceca-4deb-a14a-fa524fcc347e"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F65e7f30f-69d1-4316-bfa1-75565c769f47%2FUntitled.png?width=852&amp;table=block&amp;id=24ca2640-ceca-4deb-a14a-fa524fcc347e" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/02ceea80bfbc4906bc2a3903e12f9603" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">AQS 使用 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">int 成员变量 </strong></span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">state</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 表示同步状态</strong></span><span class="SemanticString">，通过内置的 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">线程等待队列</strong></span><span class="SemanticString"> 来完成获取资源线程的排队工作。</span></span></p></div><div id="https://www.notion.so/ba1568ec29ce4e709d28e10658bc3e48" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">state</code></span><span class="SemanticString"> 变量由 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString"> 修饰，用于展示当前临界资源的获锁情况。</span></span></p></div><pre id="https://www.notion.so/95bf84998d9943bd8b6bf4f36e593a88" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token comment">// 共享变量，使用volatile修饰保证线程可见性</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span></span></span></span></code></pre><div id="https://www.notion.so/ffef1252c1e34b3ab1f48ffc9c466721" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">另外，状态信息 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">state</code></span><span class="SemanticString"> 可以通过 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">protected</code></span><span class="SemanticString"> 类型的</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">getState()</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">setState()</code></span><span class="SemanticString">和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">compareAndSetState()</code></span><span class="SemanticString"> 进行操作。并且，这几个方法都是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">final</code></span><span class="SemanticString"> 修饰的，在子类中无法被重写。</span></span></p></div><pre id="https://www.notion.so/f34e81d3e1fb4e438ad958eb4bbe242a" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token comment">//返回同步状态的当前值</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> state<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 <span class="token comment">// 设置同步状态的值</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">int</span> newState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     state <span class="token operator">=</span> newState<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/1c1b43b05aa344ccbd700444623cd793" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">以 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString"> 为例，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">state</code></span><span class="SemanticString"> 初始值为 0，表示未锁定状态。A 线程 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">lock()</code></span><span class="SemanticString"> 时，会调用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">tryAcquire()</code></span><span class="SemanticString"> 独占该锁并将 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">state+1</code></span><span class="SemanticString"> 。此后，其他线程再 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">tryAcquire()</code></span><span class="SemanticString"> 时就会失败，直到 A 线程 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">unlock()</code></span><span class="SemanticString"> 到 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">state=</code></span><span class="SemanticString">0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">state</code></span><span class="SemanticString"> 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</span></span></p></div><h3 id="https://www.notion.so/abc3892cfcfd4871bbf6d85413e32b39" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/abc3892cfcfd4871bbf6d85413e32b39"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">AQS 资源共享方式</span></span></h3><div id="https://www.notion.so/538e1eeb2ae449ef9831950c40d29348" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">AQS 定义两种资源共享方式：</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Exclusive</code></span><span class="SemanticString">（独占，只有一个线程能执行，如</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString">）和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Share</code></span><span class="SemanticString">（共享，多个线程可同时执行，如</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Semaphore</code></span><span class="SemanticString">/</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">CountDownLatch</code></span><span class="SemanticString">）。</span></span></p></div><div id="https://www.notion.so/1a840823ea00491c96ee8b3e32538834" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一般来说，自定义同步器的共享方式要么是独占，要么是共享，他们也只需实现</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">tryAcquire-tryRelease</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">tryAcquireShared-tryReleaseShared</code></span><span class="SemanticString">中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantReadWriteLock</code></span><span class="SemanticString">。</span></span></p></div><h3 id="https://www.notion.so/977081118b76425b80237dfd372d4865" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/977081118b76425b80237dfd372d4865"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">自定义同步器</span></span></h3><div id="https://www.notion.so/2c8538c4be534dd5b5768aff6f309b43" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/328e571afd4443b5ba35b41148aaffad" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">使用者继承 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">AbstractQueuedSynchronizer</code></span><span class="SemanticString"> 并重写指定的方法。</span></span></li><li id="https://www.notion.so/d40e2877ef38436780bc27871c286765" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</span></span></li></ol><div id="https://www.notion.so/875083973ac14f9ca08dc017e9f6f7c3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</span></span></p></div><div id="https://www.notion.so/fce473e869434866bc883747edcaaf41" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：</strong></span></span></p></div><pre id="https://www.notion.so/45811a1342aa4d39a5f4b5529366aadc" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span>
<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span>
<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span>
<span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span>
<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span>
<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span></span></code></pre><div id="https://www.notion.so/bfe5420df97e4f85aaa72c8ed9b4f157" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">什么是钩子方法呢？</strong></span><span class="SemanticString"> 钩子方法是一种被声明在抽象类中的方法，一般使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">protected</code></span><span class="SemanticString"> 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</span></span></p></div><h1 id="https://www.notion.so/2267a3f822a44d9e8dc9d1273e0c2737" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/2267a3f822a44d9e8dc9d1273e0c2737"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ReentrantLock</span></span></h1><h2 id="https://www.notion.so/fc0ee0a7d1f14c2bab21cc9bb8ce316b" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/fc0ee0a7d1f14c2bab21cc9bb8ce316b"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ReentrantLock 是什么？</span></span></h2><div id="https://www.notion.so/4fcd8080a89648cf954ae2c583da6ccd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString"> 实现了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Lock</code></span><span class="SemanticString"> 接口，是一个可重入且独占式的锁，和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 关键字类似。不过，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString"> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</span></span></p></div><div id="https://www.notion.so/ebb53def5a124de9807da14be8e00ad5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString"> 里面有一个内部类 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Sync</code></span><span class="SemanticString">，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Sync</code></span><span class="SemanticString"> 继承 AQS（</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">AbstractQueuedSynchronizer</code></span><span class="SemanticString">），添加锁和释放锁的大部分操作实际上都是在 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Sync</code></span><span class="SemanticString"> 中实现的。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Sync</code></span><span class="SemanticString"> 有公平锁 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">FairSync</code></span><span class="SemanticString"> 和非公平锁 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">NonfairSync</code></span><span class="SemanticString"> 两个子类。</span></span></p></div><div id="https://www.notion.so/93a0b8acc5e544fab04f92f43fe99b8c" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc3e39f49-6f83-4fc0-a4bb-fa56b0b6e40b%2FUntitled.png?width=1630&amp;table=block&amp;id=93a0b8ac-c5e5-44fa-b04f-92f43fe99b8c"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc3e39f49-6f83-4fc0-a4bb-fa56b0b6e40b%2FUntitled.png?width=1630&amp;table=block&amp;id=93a0b8ac-c5e5-44fa-b04f-92f43fe99b8c" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/42880cd6ecaf4a95961a75169934ccb9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString"> 默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</span></span></p></div><pre id="https://www.notion.so/9b6c02cd8f1d4c958cbe0c61cb5aef77" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/23efbfd12e0d4bacb06fab19d64b94da" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">从上面的内容可以看出， </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString"> 的底层就是由 AQS 来实现的。</span></span></p></div><h3 id="https://www.notion.so/694708c715064d9bac1f068fb22df966" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/694708c715064d9bac1f068fb22df966"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">公平锁和非公平锁有什么区别？</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/035ccafccf09432eb0361b3add7c54df" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">公平锁</strong></span><span class="SemanticString"> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</span></span></li><li id="https://www.notion.so/71c3e875f18642b998987615558b181b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">非公平锁</strong></span><span class="SemanticString"> ：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</span></span></li></ul><h2 id="https://www.notion.so/5c3d6a0c74674c28b87b146a61db9a68" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/5c3d6a0c74674c28b87b146a61db9a68"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">synchronized和reentrantlock有什么区别？</span></span></h2><h3 id="https://www.notion.so/03ec506bd0374883bafa42234f644a7c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/03ec506bd0374883bafa42234f644a7c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">两者都是可重入锁。</span></span></h3><div id="https://www.notion.so/077033b02a99480798bb1b89f002d4a2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">可重入锁也称“递归锁”，指的是线程可以再次获得自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象还没有释放，这个线程可以再次获取它的锁，如果不是重入锁则会产生死锁。</span></span></p></div><div id="https://www.notion.so/1a3ea7678c914b9e8c964b4c5bbc4908" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">JDK 提供的所有现成的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Lock</code></span><span class="SemanticString">实现类，包括 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString">关键字锁都是可重入的。</span></span></p></div><h3 id="https://www.notion.so/c8cbd02c93284a29a53c451e1b68caa4" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/c8cbd02c93284a29a53c451e1b68caa4"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</span></span></h3><div id="https://www.notion.so/0d7fc489727e4a6d82d8c9e37f2bbf76" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</span></span></p></div><div id="https://www.notion.so/92d27f5fd64145be9a9f518454eccc31" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString"> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</span></span></p></div><h3 id="https://www.notion.so/a9843b72585e440792326384938bad61" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/a9843b72585e440792326384938bad61"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ReentrantLock 比 synchronized 增加了一些高级功能</span></span></h3><div id="https://www.notion.so/114f5a6d97fb4fd68ac4878a62276056" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">相比</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString">，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString">增加了一些高级功能。主要来说主要有三点：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/107409ba8b454db28f79062df72ec26c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">等待可中断</strong></span><span class="SemanticString"> : </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString">提供了一种能够中断等待锁的线程的机制，通过 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">lock.lockInterruptibly()</code></span><span class="SemanticString"> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</span></span></li><li id="https://www.notion.so/7f8d7f80237648ea9eb691f937a3298d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">可实现公平锁</strong></span><span class="SemanticString"> : </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString">可以指定是公平锁还是非公平锁。而</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString">只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString">默认情况是非公平的，可以通过 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString">类的</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock(boolean fair)</code></span><span class="SemanticString">构造方法来制定是否是公平的。</span></span></li><li id="https://www.notion.so/07241e4d5e5647d4816cc88d421e5ac2" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">可实现选择性通知（锁可以绑定多个条件）</strong></span><span class="SemanticString">: </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString">关键字与</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">wait()</code></span><span class="SemanticString">和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">notify()</code></span><span class="SemanticString">/</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">notifyAll()</code></span><span class="SemanticString">方法相结合可以实现等待/通知机制。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString">类当然也可以实现，但是需要借助于</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Condition</code></span><span class="SemanticString">接口与</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">newCondition()</code></span><span class="SemanticString">方法。</span></span></li></ul><h3 id="https://www.notion.so/f3f5e4301297401b9760bda948372ba4" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/f3f5e4301297401b9760bda948372ba4"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">可中断锁和不可中断锁有什么区别？</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/aad9e916f3cb42f2b86be3f6b9b60103" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">可中断锁</strong></span><span class="SemanticString"> ：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString"> 就属于是可中断锁。</span></span></li><li id="https://www.notion.so/12755c5976a6413495eadef678bbeb8a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不可中断锁</strong></span><span class="SemanticString"> ：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 就属于是不可中断锁。</span></span></li></ul><h1 id="https://www.notion.so/431747793d1f4f04aaa73621f6af8aea" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/431747793d1f4f04aaa73621f6af8aea"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ReentrantReadWriteLock</span></span></h1><div id="https://www.notion.so/846827ce61314076bb4212121221263b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantReadWriteLock</code></span><span class="SemanticString">实现了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReadWriteLock</code></span><span class="SemanticString">，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/b52c0bf9a86443ef85888a040b02ebd9" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。</span></span></li><li id="https://www.notion.so/20052002e0d64fad9eac646b99620697" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</span></span></li></ul><div id="https://www.notion.so/cf34bc2f9924450dbf7b1c6a5f9db5ae" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantReadWriteLock</code></span><span class="SemanticString"> 其实是两把锁，一把是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">WriteLock</code></span><span class="SemanticString"> (写锁)，一把是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReadLock</code></span><span class="SemanticString">（读锁） 。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</span></span></p></div><div id="https://www.notion.so/3b4593b108f74f7d9ced3b161e7cffa0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantLock</code></span><span class="SemanticString"> 一样，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantReadWriteLock</code></span><span class="SemanticString"> 底层也是基于 AQS 实现的。所以</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantReadWriteLock</code></span><span class="SemanticString">也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。</span></span></p></div><h3 id="https://www.notion.so/ea1e7be09f4f4eabacb40360f4ff86e2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/ea1e7be09f4f4eabacb40360f4ff86e2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">共享锁和独占锁有什么区别？</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/c99e355867394e178a742a3a34250d3e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">共享锁</strong></span><span class="SemanticString"> ：一把锁可以被多个线程同时获得。</span></span></li><li id="https://www.notion.so/bb3f0a645d74461f8ff8e3a0c34cd31e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">独占锁</strong></span><span class="SemanticString"> ：一把锁只能被一个线程获得。</span></span></li></ul><h3 id="https://www.notion.so/88d009bd3b864c859c0bba7501452f1c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/88d009bd3b864c859c0bba7501452f1c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">线程持有读锁还能获取写锁吗？</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/330c09f9edbc4fc4b647d48445154f21" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</span></span></li><li id="https://www.notion.so/88ceeb764062423fa497b0dce81e7047" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</span></span></li></ul><h3 id="https://www.notion.so/9fcacd479aa6494aa63bdf9aa63876f2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/9fcacd479aa6494aa63bdf9aa63876f2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">读锁为什么不能升级为写锁？</span></span></h3><div id="https://www.notion.so/ed0f7de035e84d62ae5c118d9d3c49cc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。</span></span></p></div><div id="https://www.notion.so/8650ff9231074ad3929c555235e5466e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。</span></span></p></div><h1 id="https://www.notion.so/fe4ae0b93a184e2db67b85b866441bac" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/fe4ae0b93a184e2db67b85b866441bac"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">StampedLock</span></span></h1><div id="https://www.notion.so/d4e9341886a64e529ee867289a3c6cd1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StampedLock</code></span><span class="SemanticString"> 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Conditon</code></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/7b0bd86bdaa4442387e1479ab9b4cc3a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">不同于一般的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Lock</code></span><span class="SemanticString"> 类，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StampedLock</code></span><span class="SemanticString"> 并不是直接实现 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Lock</code></span><span class="SemanticString">或 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReadWriteLock</code></span><span class="SemanticString">接口，而是基于 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">CLH 锁</strong></span><span class="SemanticString"> 独立实现的（AQS 也是基于这玩意）。</span></span></p></div><div id="https://www.notion.so/00e8298afac844d787c218f9fc49df2c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StampedLock</code></span><span class="SemanticString"> 提供了三种模式的读写控制模式：读锁、写锁和乐观读。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/58a7ad9bc5a9469c8c1d5ee52a7d9b17" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">写锁</strong></span><span class="SemanticString">：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantReadWriteLock</code></span><span class="SemanticString"> 的写锁，不过这里的写锁是不可重入的。</span></span></li><li id="https://www.notion.so/0c38b4746b1f40678b060abc395565ff" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">读锁</strong></span><span class="SemanticString"> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReentrantReadWriteLock</code></span><span class="SemanticString"> 的读锁，不过这里的读锁是不可重入的。</span></span></li><li id="https://www.notion.so/36551c9b15c74acbbac52633a0285302" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">乐观读</strong></span><span class="SemanticString"> ：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。</span></span></li></ul><div id="https://www.notion.so/991adf81a3c1481a97872aede238448e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">另外，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StampedLock</code></span><span class="SemanticString"> 还支持这三种锁在一定条件下进行相互转换 。</span></span></p></div><div id="https://www.notion.so/658bdfe0e9214839956bfcf2c10fa4b6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StampedLock</code></span><span class="SemanticString"> 在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，如果返回的数据戳为 0 则表示锁获取失败。当前线程持有了锁再次获取锁还是会返回一个新的数据戳，这也是</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StampedLock</code></span><span class="SemanticString">不可重入的原因。</span></span></p></div><h3 id="https://www.notion.so/172e24238086403b957b5f4614b100ae" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/172e24238086403b957b5f4614b100ae"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">StampedLock 的性能为什么更好？</span></span></h3><div id="https://www.notion.so/69a050f6396748fdb1bb37957a9c55b6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">相比于传统读写锁多出来的乐观读是</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StampedLock</code></span><span class="SemanticString">比 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ReadWriteLock</code></span><span class="SemanticString"> 性能更好的关键原因。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">StampedLock</code></span><span class="SemanticString"> 的乐观读允许一个写线程获取写锁，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。</span></span></p></div><div id="https://www.notion.so/ad88404f90ac449ea7451226af8c4610" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></article>
    <script src="https://utteranc.es/client.js"
        repo="youthtoday/youthtoday.github.io"
        issue-term="pathname"
        label="✨"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>
  <footer class="Footer">
  <div>&copy; Nick的博客 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>
