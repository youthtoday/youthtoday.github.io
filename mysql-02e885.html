<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>MySQL&nbsp;|&nbsp;Nick的博客</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="MySQL">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="-fe1f32.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📚&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>分类</span>
        </div>
      </a>
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>关于我</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">MySQL</h1>
    
      <div class="DateTagBar">
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--brown">
            <a href="tag/数据库.html">数据库</a>
          </span>
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--red">
            <a href="tag/MySQL.html">MySQL</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/02e885865a0f46cdbcd8393b10e66d75" class="PageRoot"><h1 id="https://www.notion.so/498ae04c7d8a49c890032a1e0ca4c80e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/498ae04c7d8a49c890032a1e0ca4c80e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">MySQL基础架构</span></span></h1><details id="https://www.notion.so/f65548edc1c0406aa29861ac4922f6da" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">连接器：</strong></span><span class="SemanticString"> 身份认证和权限相关(登录 MySQL 的时候)。</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/f0a50415ebea48b6b0aa54d49dbc1f28" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</span></span></p></div></div></details><details id="https://www.notion.so/c3527340ca664902b409b2a4a22856f3" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">查询缓存：</strong></span><span class="SemanticString"> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为不实用）。</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/2d60a6deb1654b9d9b2af35c7a063245" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</span></span></p></div><div id="https://www.notion.so/f49a43ee2fce4ff9812851d3a457ea52" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</span></span></p></div><div id="https://www.notion.so/ee992bd989334e9b98c520fbd48cf095" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少。</span></span></p></div></div></details><details id="https://www.notion.so/11a0311e30704dfbbff100ba8b88ecda" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">分析器：</strong></span><span class="SemanticString"> 没有命中缓存的话，SQL 语句就会经过分析器，分析器就是要先看 SQL 语句要干嘛，再检查SQL 语句语法是否正确。</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/90f18ee9acf24195a105a5a1be3160a2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第一步，词法分析</strong></span><span class="SemanticString">，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</span></span></p></div><div id="https://www.notion.so/fdbedda8023f4cabb8758a108aa0da17" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第二步，语法分析</strong></span><span class="SemanticString">，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。</span></span></p></div></div></details><details id="https://www.notion.so/4761a6ec786b4f0d94d6590e71073b45" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">优化器：</strong></span><span class="SemanticString"> 按照 MySQL 认为最优的方案去执行。</span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/22619eb4b8f3424e89f2193e8d77b494" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</span></span></p></div><div id="https://www.notion.so/ea75376ec4064832a0683a8871292b9f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</span></span></p></div></div></details><details id="https://www.notion.so/b0ff4b750e284cdd8d711c07fa35cdc6" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">执行器：</strong></span><span class="SemanticString"> 执行语句，然后从存储引擎返回数据。 </span></span></summary><div class="Toggle__Content"><div id="https://www.notion.so/73013204c42a4b50bc68a7a746e23ab2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</span></span></p></div></div></details><div id="https://www.notion.so/16201c3b74d94768a4c27a8c18611364" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd53a09e9-898f-4ac3-b21d-1aa2bfe9f4d7%2FUntitled.png?width=671&amp;table=block&amp;id=16201c3b-74d9-4768-a4c2-7a8c18611364"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd53a09e9-898f-4ac3-b21d-1aa2bfe9f4d7%2FUntitled.png?width=671&amp;table=block&amp;id=16201c3b-74d9-4768-a4c2-7a8c18611364" style="width:671px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/14cb4275b8e84564a1d136b3bea8dc19" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">简单来说 MySQL 主要分为 Server 层和存储引擎层：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/1b4f7a2698c749d4a30922ac77018346" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Server 层</strong></span><span class="SemanticString">：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。</span></span></li><li id="https://www.notion.so/a297822555b14b9f84982a2a587f271d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">存储引擎</strong></span><span class="SemanticString">： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</strong></span></span></li></ul><h1 id="https://www.notion.so/cc9f9730549641ae99b994c831a25b4c" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/cc9f9730549641ae99b994c831a25b4c"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">MySQL事务</span></span></h1><h2 id="https://www.notion.so/2d08d639b5524e03a279cfb69a635d44" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/2d08d639b5524e03a279cfb69a635d44"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">什么是事务？</span></span></h2><div id="https://www.notion.so/e53569c31f114ca7bb7d2eaa93268e40" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">事务是为了保证数据一致性的抽象的机制。事务是逻辑上的一组操作，要么都执行，要么都不执行。</span></span></p></div><div id="https://www.notion.so/99160beed069404bafd42ec9e8808633" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">比如A要给B转账100元，这里涉及到两个操作：A扣除100元，B增加100元。事务将这两个操作看作是逻辑上的一个整体，要么都成功、要么都失败。</span></span></p></div><h2 id="https://www.notion.so/db9684aafdb34c7a9256af54121bb976" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/db9684aafdb34c7a9256af54121bb976"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">什么是数据库事务？</span></span></h2><div id="https://www.notion.so/62b8b06b9ccc419c93ae908c93f91811" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">数据库事务可以保证多个对数据库的操作（SQL语句）构成一个逻辑上的整体，遵循要么全部执行成功、要么全部执行失败。</span></span></p></div><pre id="https://www.notion.so/df4b9165df8447c499282937bdda462e" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token comment"># 开启一个事务</span>
<span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token comment"># 多条 SQL 语句</span>
SQL1<span class="token punctuation">,</span>SQL2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">## 提交事务</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span></span></span></span></code></pre><div id="https://www.notion.so/ef91c84f21a146dbb173a5d42a79a134" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fef372d29-a41e-4765-9dea-b1a80159a900%2FUntitled.png?width=881&amp;table=block&amp;id=ef91c84f-21a1-46db-b173-a5d42a79a134"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fef372d29-a41e-4765-9dea-b1a80159a900%2FUntitled.png?width=881&amp;table=block&amp;id=ef91c84f-21a1-46db-b173-a5d42a79a134" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h2 id="https://www.notion.so/79f1592cd5ac4cd08794a420899d77a1" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/79f1592cd5ac4cd08794a420899d77a1"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ACID特性</span></span></h2><div id="https://www.notion.so/8f4930bdcf6f47c8a24d74576f243139" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">关系型数据库（例如：</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">MySQL</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SQL Server</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Oracle</code></span><span class="SemanticString">等）事务都有 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ACID</strong></span><span class="SemanticString">特性：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/a2965bb8c752464a8f47a9c1df42a6de" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">原子性</strong></span><span class="SemanticString">（</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Atomicity</code></span><span class="SemanticString">） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</span></span></li><li id="https://www.notion.so/327aa45cabe34117bf88997517678441" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">一致性</strong></span><span class="SemanticString">（</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Consistency</code></span><span class="SemanticString">）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</span></span></li><li id="https://www.notion.so/95359c6f0baf4d22804b936cb59d10a6" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">隔离性</strong></span><span class="SemanticString">（</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Isolation</code></span><span class="SemanticString">）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</span></span></li><li id="https://www.notion.so/449cf790dcbe4a71b07484192a194bbb" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">持久性</strong></span><span class="SemanticString">（</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Durability</code></span><span class="SemanticString">）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</span></span></li></ul><div id="https://www.notion.so/db2f322cc8db48e5922247cf51282c02" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></span></span></p></div><h2 id="https://www.notion.so/84c7900f5ba34e338de3f64573939d69" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/84c7900f5ba34e338de3f64573939d69"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">并发事务引发的问题</span></span></h2><div id="https://www.notion.so/341f0f09213342dc8033a46345c2bd7d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">多个事务并发运行，会导致操作相同的数据来完成各自的任务。可能导致以下问题。</span></span></p></div><h3 id="https://www.notion.so/4ce2a9dafaf346ef92e8c19cb405d1b7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/4ce2a9dafaf346ef92e8c19cb405d1b7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">脏读</span></span></h3><div id="https://www.notion.so/903710c0e5ca459b98dd11eb76d1364b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</span></span></p></div><div id="https://www.notion.so/6d4bc3b48fa74387a204fcc0c02c9916" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。</span></span></p></div><div id="https://www.notion.so/43af3b2ec9254894a2bd4a5ed58e7453" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1d9ca341-b894-452a-87d5-83447a550287%2FUntitled.png?width=741&amp;table=block&amp;id=43af3b2e-c925-4894-a2bd-4a5ed58e7453"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1d9ca341-b894-452a-87d5-83447a550287%2FUntitled.png?width=741&amp;table=block&amp;id=43af3b2e-c925-4894-a2bd-4a5ed58e7453" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/303e7f33fc6448fcbdcc6a2377ed4e2b" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/303e7f33fc6448fcbdcc6a2377ed4e2b"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">修改丢失</span></span></h3><div id="https://www.notion.so/54966a15847842f298c028942e2fc20a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</span></span></p></div><div id="https://www.notion.so/30c301ea66a14c2a8b9d3f39246d5367" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</span></span></p></div><div id="https://www.notion.so/1b26e1bdc6c146249b3960c66a5bc478" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F68cbe9b8-4049-46d3-9933-79f499886287%2FUntitled.png?width=624&amp;table=block&amp;id=1b26e1bd-c6c1-4624-9b39-60c66a5bc478"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F68cbe9b8-4049-46d3-9933-79f499886287%2FUntitled.png?width=624&amp;table=block&amp;id=1b26e1bd-c6c1-4624-9b39-60c66a5bc478" style="width:624px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/fe2de29bec9a4d2b957724cdac63f8a9" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/fe2de29bec9a4d2b957724cdac63f8a9"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">不可重复读</span></span></h3><div id="https://www.notion.so/b79d0daf13d543038f283b3c2ef86c0e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</span></span></p></div><div id="https://www.notion.so/e39b739ba9404bbe9217209ce5d3f598" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</span></span></p></div><div id="https://www.notion.so/86c62dd59c36438dbddc947541b579fd" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F326df179-1151-41f6-8c40-3174577f110d%2FUntitled.png?width=741&amp;table=block&amp;id=86c62dd5-9c36-438d-bddc-947541b579fd"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F326df179-1151-41f6-8c40-3174577f110d%2FUntitled.png?width=741&amp;table=block&amp;id=86c62dd5-9c36-438d-bddc-947541b579fd" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/e09f02e69cff471eac1044e4084799ac" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e09f02e69cff471eac1044e4084799ac"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">幻读</span></span></h3><div id="https://www.notion.so/de45c682eba54480888a1a1d807936fe" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</span></span></p></div><div id="https://www.notion.so/9b9ba91139e24f3192864471ddcf1750" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</span></span></p></div><div id="https://www.notion.so/5e1d9947906d462fa8091758fe6a6689" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbad5e350-ea1e-456c-83a7-8b5c760123c6%2FUntitled.png?width=731&amp;table=block&amp;id=5e1d9947-906d-462f-a809-1758fe6a6689"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbad5e350-ea1e-456c-83a7-8b5c760123c6%2FUntitled.png?width=731&amp;table=block&amp;id=5e1d9947-906d-462f-a809-1758fe6a6689" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h3 id="https://www.notion.so/4c5d41a077754c9da51a79a77ca05888" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/4c5d41a077754c9da51a79a77ca05888"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">不可重复读与幻读的区别</span></span></h3><ul class="BulletedListWrapper"><li id="https://www.notion.so/817573e761c64ab5969195e07eac8433" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">不可重复读的重点是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">内容修改</strong></span><span class="SemanticString">或者</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">记录减少</strong></span><span class="SemanticString">比如多次读取一条记录发现其中某些记录的值被修改；</span></span></li><li id="https://www.notion.so/ecd0e513832c482e9e9af60e326dd9fa" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">幻读的重点在于</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">记录新增</strong></span><span class="SemanticString">比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</span></span></li></ul><div id="https://www.notion.so/073ec56c57d64e8db34d127f4ee6703d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</span></span></p></div><div id="https://www.notion.so/1a832963d1aa4b81ac8917c707d11ab9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">举个例子：执行 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">delete</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">update</code></span><span class="SemanticString"> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">insert</code></span><span class="SemanticString"> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">insert</code></span><span class="SemanticString"> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</span></span></p></div><h3 id="https://www.notion.so/9bb88e9a798d44a3b2bc3629c39a202f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/9bb88e9a798d44a3b2bc3629c39a202f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">并发事务的控制方式有哪些？</span></span></h3><div id="https://www.notion.so/6c2fdd62d7cb470eb380eac03b084b10" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MySQL 中并发事务的控制方式无非就两种：</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">锁</strong></span><span class="SemanticString"> 和 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">MVCC</strong></span><span class="SemanticString">。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</span></span></p></div><div id="https://www.notion.so/eda91aef3b9d45c496af26932b8db045" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">锁</strong></span><span class="SemanticString">控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">读写锁</strong></span><span class="SemanticString"> 来实现并发控制。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/d587129b56e24139b42ff9ed3f96b7fe" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">共享锁（S 锁）</strong></span><span class="SemanticString"> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</span></span></li><li id="https://www.notion.so/7a28397138964fa4a2851ffd0695d9f9" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">排他锁（X 锁）</strong></span><span class="SemanticString"> ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</span></span></li></ul><div id="https://www.notion.so/ff3f07dc0c3f4b64aa8de2c4c03911b8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">表级锁(table-level locking)</strong></span><span class="SemanticString"> 和 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">行级锁(row-level locking)</strong></span><span class="SemanticString"> 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</span></span></p></div><div id="https://www.notion.so/70694d5ee8ce4a98b750d386a71dc525" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">MVCC</strong></span><span class="SemanticString"> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</span></span></p></div><div id="https://www.notion.so/a4906bdd4c754cbd95150eb9e6cdad63" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MVCC 在 MySQL 中实现所依赖的手段主要是: </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">隐藏字段、read view、undo log</strong></span><span class="SemanticString">。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/fb44a57f10924c74877a59f57269c25a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">undo log : undo log 用于记录某行数据的多个版本的数据。</span></span></li><li id="https://www.notion.so/747be724151a40888942fd1b38c6057f" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</span></span></li></ul><h3 id="https://www.notion.so/f39064b8bcf04297907073b56672e2f6" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/f39064b8bcf04297907073b56672e2f6"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">SQL 标准定义了哪些事务隔离级别?</span></span></h3><div id="https://www.notion.so/b13aba19ce964a2891304737e2ba716b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">SQL 标准定义了四个隔离级别：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/fdd20f46362243dc8eaa736867c185e5" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">READ-UNCOMMITTED(读取未提交)</strong></span><span class="SemanticString"> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</span></span></li><li id="https://www.notion.so/80600eb1b9b540ceb5bdc439a69cfa16" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">READ-COMMITTED(读取已提交)</strong></span><span class="SemanticString"> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</span></span></li><li id="https://www.notion.so/e10d3f98c9164b42a049fca9bee77a73" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">REPEATABLE-READ(可重复读)</strong></span><span class="SemanticString"> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</span></span></li><li id="https://www.notion.so/11eda866694b49ab97a5139ccfbcfe7b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">SERIALIZABLE(可串行化)</strong></span><span class="SemanticString"> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</span></span></li></ul><div><div></div><div></div><div></div><div></div><div></div></div><h3 id="https://www.notion.so/7794d1c9077c440087721626fc12ce3f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/7794d1c9077c440087721626fc12ce3f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">MySQL 的隔离级别是基于锁实现的吗？</span></span></h3><div id="https://www.notion.so/295064ab8c2041f4bfe0c08d99393edc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</span></span></p></div><div id="https://www.notion.so/ed7944c42cc24672a2b2bdb600ed9a02" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</span></span></p></div><h3 id="https://www.notion.so/f20d5e06296d4d3ab69a3e523ee0ab37" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/f20d5e06296d4d3ab69a3e523ee0ab37"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">MySQL 的默认隔离级别是什么?</strong></span></span></h3><div id="https://www.notion.so/c20125f5704043b49dba129725d31105" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MySQL InnoDB 存储引擎的默认支持的隔离级别是 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">REPEATABLE-READ（可重读）</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/69f1c188b2024de9b6aa0c2bde053099" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/81f6395441074595a243d7617ff109d2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/81f6395441074595a243d7617ff109d2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">MySQL存储引擎</span></span></h1><div id="https://www.notion.so/9743f65042954ca5bc429c081e761ff4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MySQL 支持多种存储引擎，你可以通过 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">show engines</code></span><span class="SemanticString">命令来查看 MySQL 支持的所有存储引擎。</span></span></p></div><div id="https://www.notion.so/0b2fa536a1944dce97ecd0d3a9383e94" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6e85275d-02d0-4c7c-8507-11e3c6c22ad3%2FUntitled.png?width=979&amp;table=block&amp;id=0b2fa536-a194-4dce-97ec-d0d3a9383e94"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6e85275d-02d0-4c7c-8507-11e3c6c22ad3%2FUntitled.png?width=979&amp;table=block&amp;id=0b2fa536-a194-4dce-97ec-d0d3a9383e94" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/70a29b31046840c5aecd346ac0dec350" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">所有的存储引擎中只有InnoDB是事务性存储引擎，也就是说只有InnoDB支持事务。</span></span></p></div><h2 id="https://www.notion.so/5296b42787fd4045aeaac0a6a5da6aef" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/5296b42787fd4045aeaac0a6a5da6aef"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">存储引擎架构</span></span></h2><div id="https://www.notion.so/9b4186bc20fd414380704a86886c4f57" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MySQL存储引擎采取的是</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">插件式架构</strong></span><span class="SemanticString">，支持多种存储引擎。并且可以为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不同的数据库表</strong></span><span class="SemanticString">设置不同的存储引擎。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">存储引擎是针对表</strong></span><span class="SemanticString">的，不是数据库。</span></span></p></div><div id="https://www.notion.so/027a35f863e349ac85719a3781073a7b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">还可以根据MySQL定义的存储引擎标准来编写一个属于自己的存储引擎。这些非官方的存储引擎可以称为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">第三方存储引擎</strong></span><span class="SemanticString">。InnoDB最开始就是第三方存储引擎，后来被Oracle官方收购。</span></span></p></div><h2 id="https://www.notion.so/2084a0ad351443aea0e9d33a8f332893" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/2084a0ad351443aea0e9d33a8f332893"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">MyISAM和InnoDB的区别</span></span></h2><div id="https://www.notion.so/e7e890f25cb243649a08e6a60d50c5f5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MySQL5.5之前使用MyISAM，缺点是不支持事务和行级锁，最大缺陷是崩溃后无法安全恢复。</span></span></p></div><div id="https://www.notion.so/dc7e49fb6e6d4926bac2a0596c6ab4c6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MySQL5.5之后使用InnoDB。</span></span></p></div><div id="https://www.notion.so/681da3f0137f4cf596b113c5503008f6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">1.是否支持行级锁</strong></span></span></p></div><div id="https://www.notion.so/35e2e6a4dbae42aaa3c6bf9d56950e1a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</span></span></p></div><div id="https://www.notion.so/3b664678c5144b88821c0457bb43b2e2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">2.是否支持事务</strong></span></span></p></div><div id="https://www.notion.so/ae225384f97c4d8f841f246fe287e8ed" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</span></span></p></div><div id="https://www.notion.so/5e11605e2f764e7bb58b803d381ef294" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">3.是否支持外键</strong></span></span></p></div><div id="https://www.notion.so/00c82ab2fa6748129117915bf66c4c01" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MyISAM 不支持，而 InnoDB 支持。</span></span></p></div><div id="https://www.notion.so/d4570892b88f497c88ff37c7634b71cd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</span></span></p></div><div id="https://www.notion.so/ee874e19d137488594694159580ae23a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">阿里的《Java 开发手册》也是明确规定禁止使用外键的。比如学生表中的student_id是主键，成绩表中的student_id是外键。如果更新学生表中的student_id，同时触发成绩表中的student_id就是级联更新。级联更新适用于单机低发，不适合分布式、高并发集群。</span></span></p></div><div id="https://www.notion.so/05c858a685794f179731890a29c52136" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">4.是否支持数据库异常崩溃后的安全恢复</strong></span></span></p></div><div id="https://www.notion.so/fcfdbb0b82334499a0a4bb4f84fda97c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MyISAM 不支持，而 InnoDB 支持。</span></span></p></div><div id="https://www.notion.so/e7f16acaa879439fb9460eb60106e4ce" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">redo log</code></span><span class="SemanticString"> 。</span></span></p></div><div id="https://www.notion.so/b92dfdf58fd44fc0951738bdeedeed0e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">5.是否支持 MVCC</strong></span></span></p></div><div id="https://www.notion.so/a3715bfd86be44ed844b90b43b832d4b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MyISAM 不支持，而 InnoDB 支持。</span></span></p></div><div id="https://www.notion.so/7826dd04e62f41aba966d4b6544b8ffd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。而MyISAM连行级锁都不支持。</span></span></p></div><div id="https://www.notion.so/11c6aee3cbdf40598ff60349cc8f4af8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">6.索引实现不一样。</strong></span></span></p></div><div id="https://www.notion.so/392c371c9d004aee8edbe8588688f358" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</span></span></p></div><div id="https://www.notion.so/7e74d166b90e4ab8b6e4c5098739cec8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</span></span></p></div><div id="https://www.notion.so/263edc26ba994ddbbb2167248eb52837" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">7.性能有差别。</strong></span></span></p></div><div id="https://www.notion.so/f428d187466a4cf7afb23d6532cfdfd4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。</span></span></p></div><div id="https://www.notion.so/8cc227bb457a40b38c99e867050be94c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">总结</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/d818c4a8b49f464b82951ede851d7de7" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</span></span></li><li id="https://www.notion.so/0a94961a0fcf4106988628c9093a36a2" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</span></span></li><li id="https://www.notion.so/13c558f3865946c4b939accb8bb9cf5d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">MyISAM 不支持外键，而 InnoDB 支持。</span></span></li><li id="https://www.notion.so/4bb63a15e12c4dcbb8546a7802873c11" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">MyISAM 不支持 MVVC，而 InnoDB 支持。</span></span></li><li id="https://www.notion.so/40bfa2f1343b48b6b4e9f7891b72e20e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</span></span></li><li id="https://www.notion.so/743c036c7f0e48fb8c1e31b240885c7d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</span></span></li><li id="https://www.notion.so/8665480c5d59471c874e648d755c3955" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">InnoDB 的性能比 MyISAM 更强大。</span></span></li></ul><div id="https://www.notion.so/d8d6f3ec735a4807a2f7b38fc8e8e326" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></article>
    <script src="https://utteranc.es/client.js"
        repo="youthtoday/youthtoday.github.io"
        issue-term="pathname"
        label="✨"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>
  <footer class="Footer">
  <div>&copy; Nick的博客 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>
