<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>Java并发3&nbsp;|&nbsp;Nick的博客</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="Java并发3">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="-fe1f32.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📚&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>分类</span>
        </div>
      </a>
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>关于我</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">Java并发3</h1>
    
      <div class="DateTagBar">
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--pink">
            <a href="tag/Java基础.html">Java基础</a>
          </span>
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--green">
            <a href="tag/并发编程.html">并发编程</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/0984bce564f1477c9a788d223c08860a" class="PageRoot"><h1 id="https://www.notion.so/8991652ba527455d9ba63548c004de12" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/8991652ba527455d9ba63548c004de12"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ThreadLocal</span></span></h1><h2 id="https://www.notion.so/6afcbdd30826464b846fe57bfd2b8437" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/6afcbdd30826464b846fe57bfd2b8437"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ThreadLocal作用</span></span></h2><div id="https://www.notion.so/47deee805bea4fab8914d9fd542ced38" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></span></span></p></div><div id="https://www.notion.so/a2e3a731b97841c8808d6109175ba5b2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">JDK 中自带的</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocal</code></span><span class="SemanticString">类正是为了解决这样的问题。 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ThreadLocal</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">类主要解决的就是让每个线程绑定自己的值</strong></span><span class="SemanticString">，可以将</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocal</code></span><span class="SemanticString">类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</span></span></p></div><div id="https://www.notion.so/c2bf22f3235a46639a2db472e1ab2038" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果你创建了一个</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocal</code></span><span class="SemanticString">变量，那么访问这个变量的每个线程都会有这个变量的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">本地副本</strong></span><span class="SemanticString">，这也是</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocal</code></span><span class="SemanticString">变量名的由来。他们可以使用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">get()</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">set()</code></span><span class="SemanticString"> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</span></span></p></div><h2 id="https://www.notion.so/511127328a12407bb1a56d43473495b0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/511127328a12407bb1a56d43473495b0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ThreadLocal原理</span></span></h2><div id="https://www.notion.so/5ac9ec3e0d5646fda2c68e5a44a50743" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">从 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Thread</code></span><span class="SemanticString">类源代码入手。</span></span></p></div><pre id="https://www.notion.so/84af2465819949c1acb9d8b61045966e" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment">//......</span>
    <span class="token comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span>
    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span>
    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">//......</span>
<span class="token punctuation">}</span></span></span></span></code></pre><div id="https://www.notion.so/140b1c8465e14b3abf044e39b4344008" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">从上面</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Thread</code></span><span class="SemanticString">类 源代码可以看出</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Thread</code></span><span class="SemanticString"> 类中有一个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">threadLocals</code></span><span class="SemanticString"> 和 一个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">inheritableThreadLocals</code></span><span class="SemanticString"> 变量，它们都是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocalMap</code></span><span class="SemanticString"> 类型的变量,我们可以把 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocalMap</code></span><span class="SemanticString"> 理解为</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocal</code></span><span class="SemanticString"> 类实现的定制化的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HashMap</code></span><span class="SemanticString">。默认情况下这两个变量都是 null，只有当前线程调用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocal</code></span><span class="SemanticString"> 类的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">set</code></span><span class="SemanticString">或</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">get</code></span><span class="SemanticString">方法时才创建它们，实际上调用这两个方法的时候，我们调用的是</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocalMap</code></span><span class="SemanticString">类对应的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">get()</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">set()</code></span><span class="SemanticString">方法。</span></span></p></div><div id="https://www.notion.so/9715faf1a658411784ee85288b3ad878" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">使用</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocal</code></span><span class="SemanticString">类的</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">set()</code></span><span class="SemanticString">方法时，value实际上存放在当前线程的</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocalMap</code></span><span class="SemanticString">中。ThreadLocal可以理解为只是ThreadLocalMap的封装，传递了变量值。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThrealLocal</code></span><span class="SemanticString">类中可以通过</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Thread.currentThread()</code></span><span class="SemanticString">获取到当前线程对象后，直接通过</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">getMap(Thread t)</code></span><span class="SemanticString">可以访问到该线程的</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocalMap</code></span><span class="SemanticString">对象。每个</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Thread</code></span><span class="SemanticString">中都具备一个</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocalMap</code></span><span class="SemanticString">，而</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocalMap</code></span><span class="SemanticString">可以存储以</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocal</code></span><span class="SemanticString">为 key ，Object 对象为 value 的键值对。</span></span></p></div><div id="https://www.notion.so/c63e07ca79b448d3b069c004c8db9b55" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">比如我们在同一个线程中声明了两个 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocal</code></span><span class="SemanticString"> 对象的话， </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Thread</code></span><span class="SemanticString">内部都是使用仅有的那个</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocalMap</code></span><span class="SemanticString"> 存放数据的，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocalMap</code></span><span class="SemanticString">的 key 就是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocal</code></span><span class="SemanticString">对象，value 就是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocal</code></span><span class="SemanticString"> 对象调用</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">set</code></span><span class="SemanticString">方法设置的值。</span></span></p></div><div id="https://www.notion.so/43d98d78333b468a94977bf1ea7c6965" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocal</code></span><span class="SemanticString"> 数据结构如下图所示：</span></span></p></div><div id="https://www.notion.so/e006ac251dff4bd6b7041f811a9ebfcb" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa0adc377-0dad-45ea-b101-b8f4f42ab7d4%2FUntitled.png?width=541&amp;table=block&amp;id=e006ac25-1dff-4bd6-b704-1f811a9ebfcb"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa0adc377-0dad-45ea-b101-b8f4f42ab7d4%2FUntitled.png?width=541&amp;table=block&amp;id=e006ac25-1dff-4bd6-b704-1f811a9ebfcb" style="width:541px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/5b790267308c436891d85dcc5f9da84c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocalMap</code></span><span class="SemanticString">是</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadLocal</code></span><span class="SemanticString">的静态内部类。</span></span></p></div><h2 id="https://www.notion.so/72d18c663ed54edd915cb5106b664d83" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/72d18c663ed54edd915cb5106b664d83"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">ThreadLocal内存泄露</span></span></h2><div id="https://www.notion.so/18b9f494b0e6437d8029ccfcf585a220" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">ThreadLocalMap中使用的key为ThreadLocal的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">弱引用</strong></span><span class="SemanticString">，value为</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">强引用</strong></span><span class="SemanticString">。所以如果ThreadLocal没有被外部强引用的情况下，在GC时，key会被清理，而value不会清理。进而在ThreadLocalMap中产生了key为null的键值对，如果不做任何措施，value永远不会被GC。这样就会发生内存泄露。</span></span></p></div><div id="https://www.notion.so/85fc6d00d3804715979276c91b5ce62b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">ThreadLocalMap实现中考虑到了这个情况，在调用get(), set(), remove()方法的时候会清理掉key为null的键值对。</span></span></p></div><h1 id="https://www.notion.so/fd0ed8c0891a499a8911e289c72175dc" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/fd0ed8c0891a499a8911e289c72175dc"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">线程池</span></span></h1><div id="https://www.notion.so/cf4a6f2ada1e4c3aa17e15e4bd9463f1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">线程池是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程不会立即被销毁，而是等待下一个任务。</span></span></p></div><h2 id="https://www.notion.so/a7803ea3040d425fa9e0d27a1e1151c7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/a7803ea3040d425fa9e0d27a1e1151c7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">使用线程池的好处</span></span></h2><ul class="BulletedListWrapper"><li id="https://www.notion.so/9a3df181d4e9407c9849de5a74535e6e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">降低资源消耗</strong></span><span class="SemanticString">。通过重复利用已创建的线程降低线程</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">创建和销毁</strong></span><span class="SemanticString">造成的消耗。</span></span></li><li id="https://www.notion.so/8e5b7f64281f409ea108fa8231d55710" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">提高响应速度</strong></span><span class="SemanticString">。当任务到达时，任务可以</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">不需要等待</strong></span><span class="SemanticString">线程创建就能立即执行。</span></span></li><li id="https://www.notion.so/10c56055d3cb46fd8e8c136b200c848c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">提高线程的可管理性</strong></span><span class="SemanticString">。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">分配，调优和监控</strong></span><span class="SemanticString">。</span></span></li></ul><h2 id="https://www.notion.so/2d9fc506ea5d464b940bff7a98728c95" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/2d9fc506ea5d464b940bff7a98728c95"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">如何创建线程池</span></span></h2><div id="https://www.notion.so/9238da0862fb4589b9497049b11c0e42" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">方式一：通过ThreadPoolExecutor构造函数来创建。（推荐）</span></span></p></div><div id="https://www.notion.so/b393a5609d8443678b0e0a24f75047fa" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">方式二：通过Executor框架的工具类Executors来创建。</span></span></p></div><div id="https://www.notion.so/039edc6251214feaa9b65176585ff164" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们可以创建多种类型的ThreadPoolExecutor</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/1e925d58781f4e76a03c449f457b6014" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">FixedThreadPool</strong></code></span><span class="SemanticString"> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</span></span></li><li id="https://www.notion.so/907bd04f3d26401eb6cf7e1c7a70d44e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">SingleThreadExecutor</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">：</strong></span><span class="SemanticString"> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</span></span></li><li id="https://www.notion.so/734058a9993b4339ad86afe9ffa35347" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">CachedThreadPool</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">：</strong></span><span class="SemanticString"> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</span></span></li><li id="https://www.notion.so/f161f73c4100418f9df2d7d04d7947a1" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ScheduledThreadPool</strong></code></span><span class="SemanticString"> ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</span></span></li></ul><h2 id="https://www.notion.so/3c5dbafed79a4beba6088a124b999a05" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/3c5dbafed79a4beba6088a124b999a05"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">为何不推荐使用Executors创建?</span></span></h2><div id="https://www.notion.so/7a13f2fa9b1b4e5ca4656447cd7e2317" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Executors返回线程池对象的弊端主要是OOM</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/74f20124b1e0479aa626b0a115e80a58" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">FixedThreadPool</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 和 </strong></span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">SingleThreadExecutor</strong></code></span><span class="SemanticString"> ： 使用的是无界的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedBlockingQueue</code></span><span class="SemanticString">，任务队列最大长度为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Integer.MAX_VALUE</code></span><span class="SemanticString">,可能堆积大量的请求，从而导致 OOM。</span></span></li><li id="https://www.notion.so/8f9328fdc0d34f1fab576ac5e5971db3" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">CachedThreadPool</strong></code></span><span class="SemanticString"> ：使用的是同步队列 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SynchronousQueue</code></span><span class="SemanticString">, 允许创建的线程数量为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Integer.MAX_VALUE</code></span><span class="SemanticString"> ，可能会创建大量线程，从而导致 OOM。</span></span></li><li id="https://www.notion.so/7a8dd367518643f8973341abfc57d712" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ScheduledThreadPool</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 和 </strong></span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">SingleThreadScheduledExecutor</strong></code></span><span class="SemanticString"> : 使用的无界的延迟阻塞队列</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">DelayedWorkQueue</code></span><span class="SemanticString">，任务队列最大长度为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Integer.MAX_VALUE</code></span><span class="SemanticString">,可能堆积大量的请求，从而导致 OOM。</span></span></li></ul><h2 id="https://www.notion.so/9019fc0b21f6451a9c9fa4e7656516af" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/9019fc0b21f6451a9c9fa4e7656516af"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">线程池常见参数</span></span></h2><div id="https://www.notion.so/bc863fee9b8f48cbb46b034a3ba90dc7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ThreadPoolExecutor</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> 3 个最重要的参数：</strong></span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/8cf21523411b460e867932ecc7a756f8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">corePoolSize</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> :</strong></span><span class="SemanticString"> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</span></span></li><li id="https://www.notion.so/72038ebe34ac4db8aa6ad126f8cf4b42" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">maximumPoolSize</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> :</strong></span><span class="SemanticString"> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</span></span></li><li id="https://www.notion.so/9d950ce5b5964b77bfb71bd7d0a8e4fe" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">workQueue</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">:</strong></span><span class="SemanticString"> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</span></span></li></ul><div id="https://www.notion.so/249b7382029b41a2814da1d785f3060b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ThreadPoolExecutor</code></span><span class="SemanticString">其他常见参数 :</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/a676c798cdc14fd39b929ad416b2f387" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">keepAliveTime</strong></code></span><span class="SemanticString">:线程池中的线程数量大于 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">corePoolSize</code></span><span class="SemanticString"> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">keepAliveTime</code></span><span class="SemanticString">才会被回收销毁；</span></span></li><li id="https://www.notion.so/ec494436eb554793b220c18509394a84" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">unit</strong></code></span><span class="SemanticString"> : </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">keepAliveTime</code></span><span class="SemanticString"> 参数的时间单位。</span></span></li><li id="https://www.notion.so/560e61b7cc244733bf5868c1311c9674" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">threadFactory</strong></code></span><span class="SemanticString"> :executor 创建新线程的时候会用到。</span></span></li><li id="https://www.notion.so/b20d9c85e6cf42a5badfed9cbf053534" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">handler</strong></code></span><span class="SemanticString"> :饱和策略。当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务。</span></span></li></ul><div id="https://www.notion.so/5f8789bdace84f6993c2b4915bec9fce" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9c0cebad-b4a9-43b3-b71a-473fae41f946%2FUntitled.png?width=1666&amp;table=block&amp;id=5f8789bd-ace8-4f69-93c2-b4915bec9fce"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9c0cebad-b4a9-43b3-b71a-473fae41f946%2FUntitled.png?width=1666&amp;table=block&amp;id=5f8789bd-ace8-4f69-93c2-b4915bec9fce" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h2 id="https://www.notion.so/3e7a30fabc0f45319a1e992d88ce66eb" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/3e7a30fabc0f45319a1e992d88ce66eb"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">线程池的饱和策略</span></span></h2><ul class="BulletedListWrapper"><li id="https://www.notion.so/a0d9a729cd054ae8b69c8bf0b7d0c0a2" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ThreadPoolExecutor.AbortPolicy</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">：</strong></span><span class="SemanticString"> 抛出 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">RejectedExecutionException</code></span><span class="SemanticString">来拒绝新任务的处理。</span></span></li><li id="https://www.notion.so/9a99629f8c6e4c378853c52b1a98e5dc" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ThreadPoolExecutor.CallerRunsPolicy</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">：</strong></span><span class="SemanticString"> 调用执行自己的线程运行任务，也就是直接在调用</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">execute</code></span><span class="SemanticString">方法的线程中运行(</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">run</code></span><span class="SemanticString">)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</span></span></li><li id="https://www.notion.so/46aa3761b33a4cdda35e55f3d106eae5" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ThreadPoolExecutor.DiscardPolicy</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">：</strong></span><span class="SemanticString"> 不处理新任务，直接丢弃掉。</span></span></li><li id="https://www.notion.so/e3f049b90816474698a93c73af7c6bba" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">ThreadPoolExecutor.DiscardOldestPolicy</strong></code></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">：</strong></span><span class="SemanticString"> 此策略将丢弃最早的未处理的任务请求。</span></span></li></ul><h2 id="https://www.notion.so/3169a74a699d42388b49da01d37498b0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/3169a74a699d42388b49da01d37498b0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">线程池的阻塞队列</span></span></h2><div id="https://www.notion.so/3b7316357ba94c2db53e2b521017888e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/3f838e473ab245ac9cdad0ddc9e038c5" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">LinkedBlockingQueue</code></span><span class="SemanticString">（无界队列）：</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">FixedThreadPool</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SingleThreadExector</code></span><span class="SemanticString"> 。队列长度上限为Integer.MAX_VALUE，由于队列永远不会被放满，因此</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">FixedThreadPool</code></span><span class="SemanticString">最多只能创建核心线程数的线程。</span></span></li><li id="https://www.notion.so/2961eb71451942f5996b785b37184149" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SynchronousQueue</code></span><span class="SemanticString">（同步队列） ：</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">CachedThreadPool</code></span><span class="SemanticString"> 。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SynchronousQueue</code></span><span class="SemanticString"> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">CachedThreadPool</code></span><span class="SemanticString"> 的最大线程数是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Integer.MAX_VALUE</code></span><span class="SemanticString"> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</span></span></li><li id="https://www.notion.so/91262aa6b3e44933bf20733e98f42ae4" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">DelayedWorkQueue</code></span><span class="SemanticString">（延迟阻塞队列）：</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ScheduledThreadPool</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SingleThreadScheduledExecutor</code></span><span class="SemanticString"> 。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">DelayedWorkQueue</code></span><span class="SemanticString"> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">执行时间最靠前的</strong></span><span class="SemanticString">。</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">DelayedWorkQueue</code></span><span class="SemanticString"> 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Integer.MAX_VALUE</code></span><span class="SemanticString">，所以最多只能创建核心线程数的线程。</span></span></li></ul><h2 id="https://www.notion.so/3b630dd5e81c4279b82f04f03c342b66" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/3b630dd5e81c4279b82f04f03c342b66"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">线程池处理任务流程</span></span></h2><div id="https://www.notion.so/340693d74ed440acba4a593b3b7515ee" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F973cc3d8-7b8d-44de-8f44-b95a7aa5b60b%2FUntitled.png?width=639&amp;table=block&amp;id=340693d7-4ed4-40ac-ba4a-593b3b7515ee"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F973cc3d8-7b8d-44de-8f44-b95a7aa5b60b%2FUntitled.png?width=639&amp;table=block&amp;id=340693d7-4ed4-40ac-ba4a-593b3b7515ee" style="width:639px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h2 id="https://www.notion.so/1a0810de11c64e1297b7b26d243e15b5" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/1a0810de11c64e1297b7b26d243e15b5"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">线程池合适大小</span></span></h2><div id="https://www.notion.so/6539b307c3224689b9cbbbe09acb1bd4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果线程池太小，同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</span></span></p></div><div id="https://www.notion.so/b706f003559d4d4cb13132962d2a9c8c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</span></span></p></div><div id="https://www.notion.so/ba39b8f36f394263b74d52479395759a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">有一个简单并且适用面比较广的公式：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/63cbd0cb24f6457eb0388ffaa723d755" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">CPU 密集型任务(N+1)：</strong></span><span class="SemanticString"> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</span></span></li><li id="https://www.notion.so/14688038559248cabe42cd09619c2867" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">I/O 密集型任务(2N)：</strong></span><span class="SemanticString"> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</span></span></li></ul><div id="https://www.notion.so/ced751bb51274dc48ec15979e355ed41" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></article>
    <script src="https://utteranc.es/client.js"
        repo="youthtoday/youthtoday.github.io"
        issue-term="pathname"
        label="✨"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>
  <footer class="Footer">
  <div>&copy; Nick的博客 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>
