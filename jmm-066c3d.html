<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>JMM&nbsp;|&nbsp;Nick的博客</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="JMM">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="-fe1f32.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📚&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>分类</span>
        </div>
      </a>
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>关于我</span>
        </div>
      </a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">JMM</h1>
    
      <div class="DateTagBar">
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--pink">
            <a href="tag/Java基础.html">Java基础</a>
          </span>
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--green">
            <a href="tag/并发编程.html">并发编程</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/066c3d46335a439a9043665ada18fc85" class="PageRoot"><h1 id="https://www.notion.so/5501c9fa16104a0493c1d7bb3d34cfea" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/5501c9fa16104a0493c1d7bb3d34cfea"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">JMM Java内存模型</span></span></h1><h2 id="https://www.notion.so/67cad94cfceb4c31aa485b7d0bb9e218" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/67cad94cfceb4c31aa485b7d0bb9e218"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">操作系统的内存模型</span></span></h2><div id="https://www.notion.so/7c52e849469d45e884b8f819759da5c6" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题。</span></span></p></div><div id="https://www.notion.so/c152b822797d4801ba04b8a6005ee569" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">CPU Cache 的工作方式：</strong></span><span class="SemanticString"> 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">内存缓存不一致性的问题</strong></span><span class="SemanticString"> ！比如我执行一个 i++ 操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++ 运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。</span></span></p></div><div id="https://www.notion.so/40dad53d5cb649929e87ab67dd5349c0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 </strong></span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">MESI 协议</strong></a></span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">open in new window</strong></a></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">）或者其他手段来解决。</strong></span><span class="SemanticString"> 这个缓存一致性协议指的是在 CPU 高速缓存与主内存交互的时候需要遵守的原则和规范。不同的 CPU 中，使用的缓存一致性协议通常也会有所不同。</span></span></p></div><div id="https://www.notion.so/d2c9e034f191407e8649bb451829fe66" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa99474cb-bb5e-4082-b43a-800a37399c84%2FUntitled.png?width=721&amp;table=block&amp;id=d2c9e034-f191-407e-8649-bb451829fe66"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa99474cb-bb5e-4082-b43a-800a37399c84%2FUntitled.png?width=721&amp;table=block&amp;id=d2c9e034-f191-407e-8649-bb451829fe66" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/6a44fb32cc5a448c83b4b6f8d514e86c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们的程序运行在操作系统之上，操作系统屏蔽了底层硬件的操作细节，将各种硬件资源虚拟化。于是，操作系统也就同样需要解决内存缓存不一致性问题。</span></span></p></div><div id="https://www.notion.so/1385dd6bbff54921b512e16bd135ccf9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">操作系统通过 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">内存模型（Memory Model）</strong></span><span class="SemanticString"> 定义一系列规范来解决这个问题。无论是 Windows 系统，还是 Linux 系统，它们都有特定的内存模型。</span></span></p></div><h2 id="https://www.notion.so/ccb7e0703d8d49ebb4b966152d8b8b94" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/ccb7e0703d8d49ebb4b966152d8b8b94"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">指令重排序</span></span></h2><div id="https://www.notion.so/c42f75a8b0e34d8c88bc8b262e818e89" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。</span></span></p></div><div id="https://www.notion.so/1bac82fa81744e61bb98f4f7954f33c7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">什么是指令重排序？</strong></span><span class="SemanticString"> 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。</span></span></p></div><div id="https://www.notion.so/a42dbf6d535f4bdcac95a7a97d7320a4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">常见的指令重排序有下面 2 种情况：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/7c5de2c0357e4723a02b55c0536a0a83" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">编译器优化重排</strong></span><span class="SemanticString"> ：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</span></span></li><li id="https://www.notion.so/d23419ea276945c394bdeb361589160b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">指令并行重排</strong></span><span class="SemanticString"> ：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</span></span></li></ul><div id="https://www.notion.so/b00e0bfcd4d24305a320d024ead9564d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。</span></span></p></div><div id="https://www.notion.so/b1b99cdf239942f6b02ba3c2197d6f4c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Java 源代码会经历 </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong></span><span class="SemanticString"> 的过程，最终才变成操作系统可执行的指令序列。</span></span></p></div><div id="https://www.notion.so/67beec3f444f47e4aa013b4d546da998" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong></span><span class="SemanticString"> ，所以在多线程下，指令重排序可能会导致一些问题。</span></span></p></div><h2 id="https://www.notion.so/fdb2a1f4ef1b4b63bbfc5df3c1001eab" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/fdb2a1f4ef1b4b63bbfc5df3c1001eab"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">JMM</span></span></h2><div id="https://www.notion.so/6e990892f38544078285d1765754fc9c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</span></span></p></div><div id="https://www.notion.so/44314b7794074d4cb2f3a6a456fc8330" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</span></span></p></div><div id="https://www.notion.so/1353ea8403004470bbbd23f02ab758db" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">为什么要遵守这些并发相关的原则和规范呢？</strong></span><span class="SemanticString"> 这是因为并发编程下，像 CPU 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题，为此，JMM 抽象了</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"> happens-before 原则（后文会详细介绍到）来解决这个指令重排序问题</strong></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/4008acc28dc44fd8939adf908594d4bf" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">JMM 说白了就是定义了一些规范来解决这些问题，开发者可以利用这些规范更方便地开发多线程程序。对于 Java 开发者说，你不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString">、各种 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Lock</code></span><span class="SemanticString">）即可开发出并发安全的程序。</span></span></p></div><h2 id="https://www.notion.so/8c81c0b3e9b3459dbf2c1a085b212507" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/8c81c0b3e9b3459dbf2c1a085b212507"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">JMM如何抽象线程和主内存之间的关系？</span></span></h2><div id="https://www.notion.so/92879b41482643dea58eb8bdfae2cb9e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Java 内存模型（JMM）抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。</strong></span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/1dbe80f372074e66ab06a3e7e29cf47a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">主内存</strong></span><span class="SemanticString"> ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</span></span></li><li id="https://www.notion.so/ee109510a4544ac28a8a8879cec4baa7" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">本地内存</strong></span><span class="SemanticString"> ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。</span></span></li></ul><div id="https://www.notion.so/58e8d05f708a487a833487c5975ca8f4" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe3eb3fe6-b7c1-4e4c-9a3d-f4db340bdd71%2FUntitled.png?width=551&amp;table=block&amp;id=58e8d05f-708a-487a-8334-87c5975ca8f4"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe3eb3fe6-b7c1-4e4c-9a3d-f4db340bdd71%2FUntitled.png?width=551&amp;table=block&amp;id=58e8d05f-708a-487a-8334-87c5975ca8f4" style="width:551px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/a97015008c9a40a89ccd58f2c6521417" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">从上图来看，线程 1 与线程 2 之间如果要进行通信的话，必须要经历下面 2 个步骤：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/0af8a440ce734c7bad8f4ec0b6559f7b" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去。</span></span></li><li id="https://www.notion.so/38c8164e91784418854d5c5fb767175f" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">线程 2 到主存中读取对应的共享变量的值。</span></span></li></ol><div id="https://www.notion.so/86832afd9bbe415bab466fa3818f863c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">也就是说，JMM 为共享变量提供了可见性的保障。</span></span></p></div><div id="https://www.notion.so/76fb9ee62bcf406281ae97809aa6ce55" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">不过，多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。举个例子：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/7ebc431092d8413e85f0f96b28504b84" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">线程 1 和线程 2 分别对同一个共享变量进行操作，一个执行修改，一个执行读取。</span></span></li><li id="https://www.notion.so/32977814926b4b96abdf2ae809ef3856" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">线程 2 读取到的是线程 1 修改之前的值还是修改后的值并不确定，都有可能，因为线程 1 和线程 2 都是先将共享变量从主内存拷贝到对应线程的工作内存中。</span></span></li></ol><div id="https://www.notion.so/a643df29f7c04dc3812c7f9b064a9d4f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下八种同步操作（了解即可，无需死记硬背）：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/daaffccee6474771ba6bd02dc171f403" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">锁定（lock）</strong></span><span class="SemanticString">: 作用于主内存中的变量，将他标记为一个线程独享变量。</span></span></li><li id="https://www.notion.so/a374675683df48798bc5c319ae32a33b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">解锁（unlock）</strong></span><span class="SemanticString">: 作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。</span></span></li><li id="https://www.notion.so/1baaac5ca8044402b6a9c47bfa885411" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">read（读取）</strong></span><span class="SemanticString">：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</span></span></li><li id="https://www.notion.so/209e29b346f44a74bbd31c10463166be" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">load(载入)</strong></span><span class="SemanticString">：把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。</span></span></li><li id="https://www.notion.so/f1d0a3e3b41c46c2891e10064209879f" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">use(使用)</strong></span><span class="SemanticString">：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</span></span></li><li id="https://www.notion.so/f674b22924ea4b08bd0b947e3b4db127" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">assign（赋值）</strong></span><span class="SemanticString">：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</span></span></li><li id="https://www.notion.so/191a684a75214eb4a5fd725aafef51e7" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">store（存储）</strong></span><span class="SemanticString">：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</span></span></li><li id="https://www.notion.so/ac8a59c175b740ec8fcfd143352f7bd6" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">write（写入）</strong></span><span class="SemanticString">：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</span></span></li></ul><div id="https://www.notion.so/f6466e4030194d6eb77f2cc4012ae393" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">除了这 8 种同步操作之外，还规定了下面这些同步规则来保证这些同步操作的正确执行（了解即可，无需死记硬背）：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/c40f3b0e5fc74da3a98718375206250b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。</span></span></li><li id="https://www.notion.so/4e25a42b114c484c805985aadc5f74a6" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</span></span></li><li id="https://www.notion.so/b920ec150ba14b0192df1ff451c09997" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</span></span></li><li id="https://www.notion.so/13bdc9999f8d4ae182d18a1f9c4b8381" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</span></span></li><li id="https://www.notion.so/b13042fda0f14425a60967550a3f748e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</span></span></li><li id="https://www.notion.so/120817fb295c47b1ae7375835c68ff1b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">......</span></span></li></ul><h2 id="https://www.notion.so/c1b0d381f7264972b83f2c5ea044e8a4" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/c1b0d381f7264972b83f2c5ea044e8a4"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">happens-before原则</span></span></h2><div id="https://www.notion.so/8f9b1ef669494b61b880960d5dce2440" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。</span></span></p></div><div id="https://www.notion.so/16c67d1a05a648e382facae40901dc2e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">happens-before 原则的设计思想其实非常简单：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/27ce6ef850914862b5ca6b9ec1cebc4b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">为了对编译器和处理器的约束尽可能少，只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。</span></span></li><li id="https://www.notion.so/de8fd57fdbef45a4abe828c9a9e26c6c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</span></span></li></ul><div id="https://www.notion.so/c8d9bfcd8d69443ab7e8d0e3c141c324" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3c916805-3a6f-47ad-b233-75f31b495dbf%2FUntitled.png?width=650&amp;table=block&amp;id=c8d9bfcd-8d69-443a-b7e8-d0e3c141c324"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3c916805-3a6f-47ad-b233-75f31b495dbf%2FUntitled.png?width=650&amp;table=block&amp;id=c8d9bfcd-8d69-443a-b7e8-d0e3c141c324" style="width:650px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/0fa806c8d1824a0abaf8626d3d697d88" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们看下面这段代码：</span></span></p></div><pre id="https://www.notion.so/208dc89bc17e4785bc10237ab49db338" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">int</span> userNum <span class="token operator">=</span> <span class="token function">getUserNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 1</span>
<span class="token keyword">int</span> teacherNum <span class="token operator">=</span> <span class="token function">getTeacherNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	 <span class="token comment">// 2</span>
<span class="token keyword">int</span> totalNum <span class="token operator">=</span> userNum <span class="token operator">+</span> teacherNum<span class="token punctuation">;</span>	<span class="token comment">// 3</span></span></span></span></code></pre><ul class="BulletedListWrapper"><li id="https://www.notion.so/6d0022f3f6bb4e3da8348e79b30734b8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">1 happens-before 2</span></span></li><li id="https://www.notion.so/0e7fab0e8e884f1bafc63308cd1f85fa" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">2 happens-before 3</span></span></li><li id="https://www.notion.so/ca72c58352124ba9bfd9643929ea743f" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">1 happens-before 3</span></span></li></ul><div id="https://www.notion.so/16839d97ac6047e89e425bd12667b2b7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">虽然 1 happens-before 2，但对 1 和 2 进行重排序不会影响代码的执行结果，所以 JMM 是允许编译器和处理器执行这种重排序的。但 1 和 2 必须是在 3 执行之前，也就是说 1,2 happens-before 3 。</span></span></p></div><div id="https://www.notion.so/ad319c6d180b443896112f7c8a0b464c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。</strong></span></span></p></div><h3 id="https://www.notion.so/8016069884f44923bc6ab39faa5bb913" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/8016069884f44923bc6ab39faa5bb913"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">happens-before 常见规则有哪些？</span></span></h3><div id="https://www.notion.so/d0a22a6c11864c42b3d2b29fec01b447" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">happens-before 的规则就 8 条，说多不多，重点了解下面列举的 5 条即可。全记是不可能的，很快就忘记了，意义不大，随时查阅即可。</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/072727bde14b449582dd101d3eba6e92" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">程序顺序规则</strong></span><span class="SemanticString"> ：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；</span></span></li><li id="https://www.notion.so/7b7c9f162c0444bdb8386a494fb74c49" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">解锁规则</strong></span><span class="SemanticString"> ：解锁 happens-before 于加锁；</span></span></li><li id="https://www.notion.so/833e9de402ae4a7eb7f07c10f1c1ea17" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">volatile 变量规则</strong></span><span class="SemanticString"> ：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。</span></span></li><li id="https://www.notion.so/a35bdf70c04d41ae918a919cd6de9b37" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">传递规则</strong></span><span class="SemanticString"> ：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</span></span></li><li id="https://www.notion.so/6384160f4bdf44c0829a12619c68623e" class="NumberedList" value="5"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">线程启动规则</strong></span><span class="SemanticString"> ：Thread 对象的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">start()</code></span><span class="SemanticString">方法 happens-before 于此线程的每一个动作。</span></span></li></ol><div id="https://www.notion.so/0dc8f43064e64567b75deb0e54cf0e95" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果两个操作不满足上述任意一个 happens-before 规则，那么这两个操作就没有顺序的保障，JVM 可以对这两个操作进行重排序。</span></span></p></div><h2 id="https://www.notion.so/8535c27cabfa41c3836cf1d8e5690af1" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/8535c27cabfa41c3836cf1d8e5690af1"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">再看并发编程三个重要特性</span></span></h2><h3 id="https://www.notion.so/f26201ecd9764370898cac85cc025270" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/f26201ecd9764370898cac85cc025270"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">原子性</span></span></h3><div id="https://www.notion.so/9709b67b394a4d99b15d35ae3c000578" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</span></span></p></div><div id="https://www.notion.so/897f4f9a2f9b4b5b94b73148daa4ab89" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 Java 中，可以借助</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 、各种 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Lock</code></span><span class="SemanticString"> 以及各种原子类实现原子性。</span></span></p></div><div id="https://www.notion.so/e583e7f0c5dc4616b148d0bade85652a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 和各种 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Lock</code></span><span class="SemanticString"> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString">或者</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">final</code></span><span class="SemanticString">关键字）来保证原子操作。</span></span></p></div><h3 id="https://www.notion.so/d07f8184e8c34e95afd3ed506dff4e3d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/d07f8184e8c34e95afd3ed506dff4e3d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">可见性</span></span></h3><div id="https://www.notion.so/a1dc382ffe3241b69e69909a5de8d929" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</span></span></p></div><div id="https://www.notion.so/b01e621f54d742b59dec03555822843a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 Java 中，可以借助</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">synchronized</code></span><span class="SemanticString"> 、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString"> 以及各种 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Lock</code></span><span class="SemanticString"> 实现可见性。</span></span></p></div><div id="https://www.notion.so/d5e84df98e214549b77c742a33dfe038" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果我们将变量声明为 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString"> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</span></span></p></div><h3 id="https://www.notion.so/e1d12246b8bc4ebcbacc56bb001b205a" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/e1d12246b8bc4ebcbacc56bb001b205a"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">有序性</span></span></h3><div id="https://www.notion.so/25889e98023f487ca883647b42ca5f8b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</span></span></p></div><div id="https://www.notion.so/bf95267c193e4e7b8bb1dbd9da19d6ca" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">我们上面讲重排序的时候也提到过：</span></span></p></div><blockquote id="https://www.notion.so/337749e8495c4318b5df86fe92a5e996" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。</span></span></blockquote><div id="https://www.notion.so/482825005421462cb6134c65672f8865" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 Java 中，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">volatile</code></span><span class="SemanticString"> 关键字可以禁止指令进行重排序优化。</span></span></p></div><div id="https://www.notion.so/22b6966588b84b94a14085e26648a6e1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></article>
    <script src="https://utteranc.es/client.js"
        repo="youthtoday/youthtoday.github.io"
        issue-term="pathname"
        label="✨"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>
  <footer class="Footer">
  <div>&copy; Nick的博客 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>
